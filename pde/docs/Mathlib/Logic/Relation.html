<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="icon" href="../.././favicon.svg"></link><link rel="mask-icon" href="../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Logic.Relation</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Logic.Relation";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Logic</span>.<span class="name">Relation</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Logic/Basic.html">Mathlib.Logic.Basic</a></li><li><a href="../.././Mathlib/Logic/Relator.html">Mathlib.Logic.Relator</a></li><li><a href="../.././Mathlib/Tactic/MkIffOfInductiveProp.html">Mathlib.Tactic.MkIffOfInductiveProp</a></li><li><a href="../.././Mathlib/Tactic/SimpRw.html">Mathlib.Tactic.SimpRw</a></li><li><a href="../.././Mathlib/Tactic/Use.html">Mathlib.Tactic.Use</a></li><li><a href="../.././Mathlib/Order/Defs/Unbundled.html">Mathlib.Order.Defs.Unbundled</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Logic.Relation" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#IsRefl.reflexive"><span class="name">IsRefl</span>.<span class="name">reflexive</span></a></div><div class="nav_link"><a class="break_within" href="#Reflexive.rel_of_ne_imp"><span class="name">Reflexive</span>.<span class="name">rel_of_ne_imp</span></a></div><div class="nav_link"><a class="break_within" href="#Reflexive.ne_imp_iff"><span class="name">Reflexive</span>.<span class="name">ne_imp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#reflexive_ne_imp_iff"><span class="name">reflexive_ne_imp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Symmetric.iff"><span class="name">Symmetric</span>.<span class="name">iff</span></a></div><div class="nav_link"><a class="break_within" href="#Symmetric.flip_eq"><span class="name">Symmetric</span>.<span class="name">flip_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Symmetric.swap_eq"><span class="name">Symmetric</span>.<span class="name">swap_eq</span></a></div><div class="nav_link"><a class="break_within" href="#flip_eq_iff"><span class="name">flip_eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#swap_eq_iff"><span class="name">swap_eq_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Reflexive.comap"><span class="name">Reflexive</span>.<span class="name">comap</span></a></div><div class="nav_link"><a class="break_within" href="#Symmetric.comap"><span class="name">Symmetric</span>.<span class="name">comap</span></a></div><div class="nav_link"><a class="break_within" href="#Transitive.comap"><span class="name">Transitive</span>.<span class="name">comap</span></a></div><div class="nav_link"><a class="break_within" href="#Equivalence.comap"><span class="name">Equivalence</span>.<span class="name">comap</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.Comp"><span class="name">Relation</span>.<span class="name">Comp</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.comp_eq_fun"><span class="name">Relation</span>.<span class="name">comp_eq_fun</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.comp_eq"><span class="name">Relation</span>.<span class="name">comp_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.fun_eq_comp"><span class="name">Relation</span>.<span class="name">fun_eq_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.eq_comp"><span class="name">Relation</span>.<span class="name">eq_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.iff_comp"><span class="name">Relation</span>.<span class="name">iff_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.comp_iff"><span class="name">Relation</span>.<span class="name">comp_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.comp_assoc"><span class="name">Relation</span>.<span class="name">comp_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.flip_comp"><span class="name">Relation</span>.<span class="name">flip_comp</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.Fibration"><span class="name">Relation</span>.<span class="name">Fibration</span></a></div><div class="nav_link"><a class="break_within" href="#Acc.of_fibration"><span class="name">Acc</span>.<span class="name">of_fibration</span></a></div><div class="nav_link"><a class="break_within" href="#Acc.of_downward_closed"><span class="name">Acc</span>.<span class="name">of_downward_closed</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.Map"><span class="name">Relation</span>.<span class="name">Map</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.map_apply"><span class="name">Relation</span>.<span class="name">map_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.map_map"><span class="name">Relation</span>.<span class="name">map_map</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.map_apply_apply"><span class="name">Relation</span>.<span class="name">map_apply_apply</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.map_id_id"><span class="name">Relation</span>.<span class="name">map_id_id</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.instDecidableMapOfExistsAndEq"><span class="name">Relation</span>.<span class="name">instDecidableMapOfExistsAndEq</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.map_reflexive"><span class="name">Relation</span>.<span class="name">map_reflexive</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.map_symmetric"><span class="name">Relation</span>.<span class="name">map_symmetric</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.map_transitive"><span class="name">Relation</span>.<span class="name">map_transitive</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.map_equivalence"><span class="name">Relation</span>.<span class="name">map_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.map_mono"><span class="name">Relation</span>.<span class="name">map_mono</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen"><span class="name">Relation</span>.<span class="name">ReflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.cases_tail_iff"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_tail_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflGen"><span class="name">Relation</span>.<span class="name">ReflGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflGen_iff"><span class="name">Relation</span>.<span class="name">reflGen_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.EqvGen"><span class="name">Relation</span>.<span class="name">EqvGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.eqvGen_iff"><span class="name">Relation</span>.<span class="name">eqvGen_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transGen_iff"><span class="name">Relation</span>.<span class="name">transGen_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflGen.to_reflTransGen"><span class="name">Relation</span>.<span class="name">ReflGen</span>.<span class="name">to_reflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflGen.mono"><span class="name">Relation</span>.<span class="name">ReflGen</span>.<span class="name">mono</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflGen.instIsRefl"><span class="name">Relation</span>.<span class="name">ReflGen</span>.<span class="name">instIsRefl</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.trans"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.single"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">single</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.head"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">head</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.symmetric"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">symmetric</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.cases_tail"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_tail</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.head_induction_on"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">head_induction_on</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.trans_induction_on"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">trans_induction_on</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.cases_head"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_head</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.cases_head_iff"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_head_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.total_of_right_unique"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">total_of_right_unique</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.to_reflTransGen"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">to_reflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.trans_left"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans_left</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.head'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head'</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.tail'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">tail'</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.head"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.head_induction_on"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head_induction_on</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.trans_induction_on"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans_induction_on</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.trans_right"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans_right</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.tail'_iff"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">tail'_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.head'_iff"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head'_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflGen_eq_self"><span class="name">Relation</span>.<span class="name">reflGen_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflexive_reflGen"><span class="name">Relation</span>.<span class="name">reflexive_reflGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflGen_minimal"><span class="name">Relation</span>.<span class="name">reflGen_minimal</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.instIsTransTransGen"><span class="name">Relation</span>.<span class="name">instIsTransTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.instTransTransGen_mathlib"><span class="name">Relation</span>.<span class="name">instTransTransGen_mathlib</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.instTransTransGen_mathlib_1"><span class="name">Relation</span>.<span class="name">instTransTransGen_mathlib_1</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.instTransTransGenReflTransGen"><span class="name">Relation</span>.<span class="name">instTransTransGenReflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.instTransReflTransGenTransGen"><span class="name">Relation</span>.<span class="name">instTransReflTransGenTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transGen_eq_self"><span class="name">Relation</span>.<span class="name">transGen_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transitive_transGen"><span class="name">Relation</span>.<span class="name">transitive_transGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transGen_idem"><span class="name">Relation</span>.<span class="name">transGen_idem</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.lift"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">lift</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.lift'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">lift'</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.closed"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">closed</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.closed'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">closed'</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.mono"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">mono</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transGen_minimal"><span class="name">Relation</span>.<span class="name">transGen_minimal</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.TransGen.swap"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">swap</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transGen_swap"><span class="name">Relation</span>.<span class="name">transGen_swap</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_iff_eq"><span class="name">Relation</span>.<span class="name">reflTransGen_iff_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_iff_eq_or_transGen"><span class="name">Relation</span>.<span class="name">reflTransGen_iff_eq_or_transGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.lift"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">lift</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.mono"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">mono</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_eq_self"><span class="name">Relation</span>.<span class="name">reflTransGen_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_minimal"><span class="name">Relation</span>.<span class="name">reflTransGen_minimal</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflexive_reflTransGen"><span class="name">Relation</span>.<span class="name">reflexive_reflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transitive_reflTransGen"><span class="name">Relation</span>.<span class="name">transitive_reflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.instTransReflTransGen"><span class="name">Relation</span>.<span class="name">instTransReflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.instTransReflTransGen_1"><span class="name">Relation</span>.<span class="name">instTransReflTransGen_1</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.instIsReflReflTransGen"><span class="name">Relation</span>.<span class="name">instIsReflReflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.instIsTransReflTransGen"><span class="name">Relation</span>.<span class="name">instIsTransReflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_idem"><span class="name">Relation</span>.<span class="name">reflTransGen_idem</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.lift'"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">lift'</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_closed"><span class="name">Relation</span>.<span class="name">reflTransGen_closed</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.ReflTransGen.swap"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">swap</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_swap"><span class="name">Relation</span>.<span class="name">reflTransGen_swap</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflGen_transGen"><span class="name">Relation</span>.<span class="name">reflGen_transGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transGen_reflGen"><span class="name">Relation</span>.<span class="name">transGen_reflGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_reflGen"><span class="name">Relation</span>.<span class="name">reflTransGen_reflGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_transGen"><span class="name">Relation</span>.<span class="name">reflTransGen_transGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_eq_transGen"><span class="name">Relation</span>.<span class="name">reflTransGen_eq_transGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_eq_reflGen"><span class="name">Relation</span>.<span class="name">reflTransGen_eq_reflGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.EqvGen.is_equivalence"><span class="name">Relation</span>.<span class="name">EqvGen</span>.<span class="name">is_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.EqvGen.setoid"><span class="name">Relation</span>.<span class="name">EqvGen</span>.<span class="name">setoid</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.EqvGen.mono"><span class="name">Relation</span>.<span class="name">EqvGen</span>.<span class="name">mono</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.Join"><span class="name">Relation</span>.<span class="name">Join</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.church_rosser"><span class="name">Relation</span>.<span class="name">church_rosser</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.join_of_single"><span class="name">Relation</span>.<span class="name">join_of_single</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.symmetric_join"><span class="name">Relation</span>.<span class="name">symmetric_join</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflexive_join"><span class="name">Relation</span>.<span class="name">reflexive_join</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.transitive_join"><span class="name">Relation</span>.<span class="name">transitive_join</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.equivalence_join"><span class="name">Relation</span>.<span class="name">equivalence_join</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.equivalence_join_reflTransGen"><span class="name">Relation</span>.<span class="name">equivalence_join_reflTransGen</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.join_of_equivalence"><span class="name">Relation</span>.<span class="name">join_of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_of_transitive_reflexive"><span class="name">Relation</span>.<span class="name">reflTransGen_of_transitive_reflexive</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.reflTransGen_of_equivalence"><span class="name">Relation</span>.<span class="name">reflTransGen_of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.eqvGen_exact"><span class="name">Quot</span>.<span class="name">eqvGen_exact</span></a></div><div class="nav_link"><a class="break_within" href="#Quot.eqvGen_sound"><span class="name">Quot</span>.<span class="name">eqvGen_sound</span></a></div><div class="nav_link"><a class="break_within" href="#Equivalence.eqvGen_iff"><span class="name">Equivalence</span>.<span class="name">eqvGen_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Equivalence.eqvGen_eq"><span class="name">Equivalence</span>.<span class="name">eqvGen_eq</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Relation-closures">Relation closures <a class="hover-link" href="#Relation-closures">#</a></h1><p>This file defines the reflexive, transitive, reflexive transitive and equivalence closures
of relations and proves some basic results on them.</p><p>Note that this is about unbundled relations, that is terms of types of the form <code>α → β → Prop</code>. For
the bundled version, see <code>Rel</code>.</p><h2 class="markdown-heading" id="Definitions">Definitions <a class="hover-link" href="#Definitions">#</a></h2><ul>
<li><code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">Relation.ReflGen</a></code>: Reflexive closure. <code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> r</code> relates everything <code>r</code> related, plus for all
<code>a</code> it relates <code>a</code> with itself. So <code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> r a b ↔ r a b ∨ a = b</code>.</li>
<li><code><a href="../.././Init/Core.html#Relation.TransGen">Relation.TransGen</a></code>: Transitive closure. <code>TransGen r</code> relates everything <code>r</code> related
transitively. So <code>TransGen r a b ↔ ∃ x₀ ... xₙ, r a x₀ ∧ r x₀ x₁ ∧ ... ∧ r xₙ b</code>.</li>
<li><code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">Relation.ReflTransGen</a></code>: Reflexive transitive closure. <code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> r</code> relates everything
<code>r</code> related transitively, plus for all <code>a</code> it relates <code>a</code> with itself. So
<code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> r a b ↔ (∃ x₀ ... xₙ, r a x₀ ∧ r x₀ x₁ ∧ ... ∧ r xₙ b) ∨ a = b</code>. It is the same as
the reflexive closure of the transitive closure, or the transitive closure of the reflexive
closure. In terms of rewriting systems, this means that <code>a</code> can be rewritten to <code>b</code> in a number of
rewrites.</li>
<li><code><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a></code>: Equivalence closure. <code><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">EqvGen</a> r</code> relates everything <code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> r</code> relates,
plus for all related pairs it relates them in the opposite order.</li>
<li><code><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a></code>:  Relation composition. We provide notation <code>∘r</code>. For <code>r : α → β → Prop</code> and
<code>s : β → γ → Prop</code>, <code>r ∘r s</code>relates <code>a : α</code> and <code>c : γ</code> iff there exists <code>b : β</code> that's related to
both.</li>
<li><code><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a></code>: Image of a relation under a pair of maps. For <code>r : α → β → Prop</code>, <code>f : α → γ</code>,
<code>g : β → δ</code>, <code><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Map</a> r f g</code> is the relation <code>γ → δ → Prop</code> relating <code>f a</code> and <code>g b</code> for all <code>a</code>, <code>b</code>
related by <code>r</code>.</li>
<li><code><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a></code>: Join of a relation. For <code>r : α → α → Prop</code>, <code><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Join</a> r a b ↔ ∃ c, r a c ∧ r b c</code>. In
terms of rewriting systems, this means that <code>a</code> and <code>b</code> can be rewritten to the same term.</li>
</ul></div><div class="decl" id="IsRefl.reflexive"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L55-L55">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#IsRefl.reflexive"><span class="name">IsRefl</span>.<span class="name">reflexive</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#IsRefl">IsRefl</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Reflexive.rel_of_ne_imp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L57-L62">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Reflexive.rel_of_ne_imp"><span class="name">Reflexive</span>.<span class="name">rel_of_ne_imp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hr</span> : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div><p>To show a reflexive relation <code>r : α → α → Prop</code> holds over <code>x y : α</code>,
it suffices to show it holds when <code>x ≠ y</code>.</p></div></div><div class="decl" id="Reflexive.ne_imp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L65-L68">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Reflexive.ne_imp_iff"><span class="name">Reflexive</span>.<span class="name">ne_imp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div><p>If a reflexive relation <code>r : α → α → Prop</code> holds over <code>x y : α</code>,
then it holds whether or not <code>x ≠ y</code>.</p></div></div><div class="decl" id="reflexive_ne_imp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L70-L73">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#reflexive_ne_imp_iff"><span class="name">reflexive_ne_imp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#IsRefl">IsRefl</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div><p>If a reflexive relation <code>r : α → α → Prop</code> holds over <code>x y : α</code>,
then it holds whether or not <code>x ≠ y</code>. Unlike <code><a href="../.././Mathlib/Logic/Relation.html#Reflexive.ne_imp_iff">Reflexive.ne_imp_iff</a></code>, this uses <code>[IsRefl α r]</code>.</p></div></div><div class="decl" id="Symmetric.iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L75-L76">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Symmetric.iff"><span class="name">Symmetric</span>.<span class="name">iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">r</span> <span class="fn">y</span> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="Symmetric.flip_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L78-L79">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Symmetric.flip_eq"><span class="name">Symmetric</span>.<span class="name">flip_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#flip">flip</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></div></div></div></div><div class="decl" id="Symmetric.swap_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L81-L82">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Symmetric.swap_eq"><span class="name">Symmetric</span>.<span class="name">swap_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">r</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="flip_eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L84-L85">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#flip_eq_iff"><span class="name">flip_eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#flip">flip</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="swap_eq_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L87-L88">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#swap_eq_iff"><span class="name">swap_eq_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Reflexive.comap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L96-L96">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Reflexive.comap"><span class="name">Reflexive</span>.<span class="name">comap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">(<a href="../.././Mathlib/Logic/Function/Defs.html#Function.onFun">Function.onFun</a> <span class="fn">r</span> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Symmetric.comap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L98-L98">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Symmetric.comap"><span class="name">Symmetric</span>.<span class="name">comap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">(<a href="../.././Mathlib/Logic/Function/Defs.html#Function.onFun">Function.onFun</a> <span class="fn">r</span> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Transitive.comap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L100-L101">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Transitive.comap"><span class="name">Transitive</span>.<span class="name">comap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">(<a href="../.././Mathlib/Logic/Function/Defs.html#Function.onFun">Function.onFun</a> <span class="fn">r</span> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Equivalence.comap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L103-L104">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Equivalence.comap"><span class="name">Equivalence</span>.<span class="name">comap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">(<a href="../.././Mathlib/Logic/Function/Defs.html#Function.onFun">Function.onFun</a> <span class="fn">r</span> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Relation.Comp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L114-L119">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.Comp"><span class="name">Relation</span>.<span class="name">Comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">γ</span> → <a href="../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn">γ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>The composition of two relations, yielding a new relation.  The result
relates a term of <code>α</code> and a term of <code>γ</code> if there is an intermediate
term of <code>β</code> related to both.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Relation.Comp</a> <span class="fn">r</span> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn">b</span> <span class="fn">c</span></span></li></ul></details><details id="instances-for-list-Relation.Comp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.comp_eq_fun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L124-L127">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.comp_eq_fun"><span class="name">Relation</span>.<span class="name">comp_eq_fun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">γ</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Comp</a> <span class="fn">r</span> <span class="fn">fun (<span class="fn">x1</span> : <span class="fn">β</span>) (<span class="fn">x2</span> : <span class="fn">γ</span>) =&gt; <span class="fn">x1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">x2</span></span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">fun (<span class="fn">x1</span> : <span class="fn">α</span>) (<span class="fn">x2</span> : <span class="fn">γ</span>) =&gt; <span class="fn"><span class="fn">r</span> <span class="fn">x1</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x2</span>)</span></span></span></div></div></div></div><div class="decl" id="Relation.comp_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L129-L130">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.comp_eq"><span class="name">Relation</span>.<span class="name">comp_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Comp</a> <span class="fn">r</span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">β</span>) =&gt; <span class="fn">x1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x2</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></div></div></div></div><div class="decl" id="Relation.fun_eq_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L132-L135">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.fun_eq_comp"><span class="name">Relation</span>.<span class="name">fun_eq_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">γ</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Comp</a> <span class="fn">(fun (<span class="fn">x1</span> : <span class="fn">γ</span>) (<span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">x1</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x2</span>)</span> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <span class="fn"><span class="fn">r</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span></span></div></div></div></div><div class="decl" id="Relation.eq_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L137-L138">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.eq_comp"><span class="name">Relation</span>.<span class="name">eq_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Comp</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x2</span>)</span> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></div></div></div></div><div class="decl" id="Relation.iff_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L140-L143">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.iff_comp"><span class="name">Relation</span>.<span class="name">iff_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Comp</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <a href="../.././foundational_types.html">Prop</a>) =&gt; <span class="fn">x1</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">x2</span>)</span> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></div></div></div></div><div class="decl" id="Relation.comp_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L145-L148">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.comp_iff"><span class="name">Relation</span>.<span class="name">comp_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href="../.././foundational_types.html">Prop</a> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Comp</a> <span class="fn">r</span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <a href="../.././foundational_types.html">Prop</a>) =&gt; <span class="fn">x1</span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">x2</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></div></div></div></div><div class="decl" id="Relation.comp_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L150-L155">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.comp_assoc"><span class="name">Relation</span>.<span class="name">comp_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">γ</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">q</span> : <span class="fn"><span class="fn">γ</span> → <span class="fn"><span class="fn">δ</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Comp</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Comp</a> <span class="fn">r</span> <span class="fn">p</span>)</span> <span class="fn">q</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Comp</a> <span class="fn">r</span> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Comp</a> <span class="fn">p</span> <span class="fn">q</span>)</span></span></div></div></div></div><div class="decl" id="Relation.flip_comp"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L157-L162">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.flip_comp"><span class="name">Relation</span>.<span class="name">flip_comp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">γ</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#flip">flip</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Comp</a> <span class="fn">r</span> <span class="fn">p</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Comp">Comp</a> <span class="fn">(<a href="../.././Init/Core.html#flip">flip</a> <span class="fn">p</span>)</span> <span class="fn">(<a href="../.././Init/Core.html#flip">flip</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.Fibration"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L170-L174">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.Fibration"><span class="name">Relation</span>.<span class="name">Fibration</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">rα</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">rβ</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>A function <code>f : α → β</code> is a fibration between the relation <code>rα</code> and <code>rβ</code> if for all
<code>a : α</code> and <code>b : β</code>, whenever <code>b : β</code> and <code>f a</code> are related by <code>rβ</code>, <code>b</code> is the image
of some <code>a' : α</code> under <code>f</code>, and <code>a'</code> and <code>a</code> are related by <code>rα</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Fibration">Relation.Fibration</a> <span class="fn">rα</span> <span class="fn">rβ</span> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">∀ ⦃<span class="fn">a</span> : <span class="fn">α</span>⦄ ⦃<span class="fn">b</span> : <span class="fn">β</span>⦄, <span class="fn"><span class="fn"><span class="fn">rβ</span> <span class="fn">b</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span> → <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a'</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">rα</span> <span class="fn">a'</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">f</span> <span class="fn">a'</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></li></ul></details><details id="instances-for-list-Relation.Fibration" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Acc.of_fibration"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L178-L184">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Acc.of_fibration"><span class="name">Acc</span>.<span class="name">of_fibration</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">rα</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">rβ</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fib</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Fibration">Relation.Fibration</a> <span class="fn">rα</span> <span class="fn">rβ</span> <span class="fn">f</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <span class="fn"><a href="../.././Init/WF.html#Acc">Acc</a> <span class="fn">rα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/WF.html#Acc">Acc</a> <span class="fn">rβ</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></div></div><p>If <code>f : α → β</code> is a fibration between relations <code>rα</code> and <code>rβ</code>, and <code>a : α</code> is
accessible under <code>rα</code>, then <code>f a</code> is accessible under <code>rβ</code>.</p></div></div><div class="decl" id="Acc.of_downward_closed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L186-L190">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Acc.of_downward_closed"><span class="name">Acc</span>.<span class="name">of_downward_closed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">rβ</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">dc</span> : <span class="fn">∀ {<span class="fn">a</span> : <span class="fn">α</span>} {<span class="fn">b</span> : <span class="fn">β</span>}, <span class="fn"><span class="fn"><span class="fn">rβ</span> <span class="fn">b</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span> → <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">c</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <span class="fn"><a href="../.././Init/WF.html#Acc">Acc</a> <span class="fn">(<a href="../.././Init/Core.html#InvImage">InvImage</a> <span class="fn">rβ</span> <span class="fn">f</span>)</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/WF.html#Acc">Acc</a> <span class="fn">rβ</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span></div></div></div></div><div class="decl" id="Relation.Map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L197-L203">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.Map"><span class="name">Relation</span>.<span class="name">Map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">γ</span> → <span class="fn"><span class="fn">δ</span> → <a href="../.././foundational_types.html">Prop</a></span></span></div></div><p>The map of a relation <code>r</code> through a pair of functions pushes the
relation to the codomains of the functions.  The resulting relation is
defined by having pairs of terms related if they have preimages
related by <code>r</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">c</span> <span class="fn">d</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">g</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></li></ul></details><details id="instances-for-list-Relation.Map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.map_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L205-L205">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.map_apply"><span class="name">Relation</span>.<span class="name">map_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn">γ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">d</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">c</span> <span class="fn">d</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">g</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></div></div></div></div><div class="decl" id="Relation.map_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L207-L213">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.map_map"><span class="name">Relation</span>.<span class="name">map_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ε</span> : <a href="../.././foundational_types.html">Type</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ζ</span> : <a href="../.././foundational_types.html">Type</a> u_6}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f₁</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g₁</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f₂</span> : <span class="fn"><span class="fn">γ</span> → <span class="fn">ε</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">g₂</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn">ζ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">f₁</span> <span class="fn">g₁</span>)</span> <span class="fn">f₂</span> <span class="fn">g₂</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> (<span class="fn">f₂</span> <a href="../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f₁</span>) (<span class="fn">g₂</span> <a href="../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">g₁</span>)</span></div></div></div></div><div class="decl" id="Relation.map_apply_apply"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L215-L217">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.map_apply_apply"><span class="name">Relation</span>.<span class="name">map_apply_apply</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hg</span> : <span class="fn"><a href="../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">g</span> <span class="fn">b</span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.map_id_id"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L219-L219">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.map_id_id"><span class="name">Relation</span>.<span class="name">map_id_id</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <a href="../.././Init/Prelude.html#id">id</a> <a href="../.././Init/Prelude.html#id">id</a></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></div></div></div></div><div class="decl" id="Relation.instDecidableMapOfExistsAndEq"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L221-L222">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.instDecidableMapOfExistsAndEq"><span class="name">Relation</span>.<span class="name">instDecidableMapOfExistsAndEq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">c</span> : <span class="fn">γ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">d</span> : <span class="fn">δ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> (<a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">β</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">g</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span>)</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">c</span> <span class="fn">d</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Logic/Relation.html#Relation.instDecidableMapOfExistsAndEq">Relation.instDecidableMapOfExistsAndEq</a> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">inst✝</span></li></ul></details></div></div><div class="decl" id="Relation.map_reflexive"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L224-L228">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.map_reflexive"><span class="name">Relation</span>.<span class="name">map_reflexive</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hr</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../.././Mathlib/Logic/Function/Defs.html#Function.Surjective">Function.Surjective</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Relation.map_symmetric"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L230-L232">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.map_symmetric"><span class="name">Relation</span>.<span class="name">map_symmetric</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hr</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Relation.map_transitive"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L234-L238">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.map_transitive"><span class="name">Relation</span>.<span class="name">map_transitive</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hr</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Relation.map_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L240-L245">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.map_equivalence"><span class="name">Relation</span>.<span class="name">map_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hr</span> : <span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../.././Mathlib/Logic/Function/Defs.html#Function.Surjective">Function.Surjective</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf_ker</span> : <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">f</span>)</span></span></div></div></div></div><div class="decl" id="Relation.map_mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L248-L250">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.map_mono"><span class="name">Relation</span>.<span class="name">map_mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r </span><span class="fn">s</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">g</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">y</span> : <span class="fn">β</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">s</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">γ</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">y</span> : <span class="fn">δ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">r</span> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Map">Relation.Map</a> <span class="fn">s</span> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">x</span> <span class="fn">y</span></span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L256-L260">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen"><span class="name">Relation</span>.<span class="name">ReflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></div></div><p><code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> r</code>: reflexive transitive closure of <code>r</code></p><ul class="constructors"><li class="constructor" id="Relation.ReflTransGen.refl">refl<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">a</span></span></li><li class="constructor" id="Relation.ReflTransGen.tail">tail<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></span></span></li></ul><details id="instances-for-list-Relation.ReflTransGen" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.ReflTransGen.cases_tail_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L257-L257">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.cases_tail_iff"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_tail_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">a✝</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">a✝</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a✝</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">a✝</span></span></div></div></div></div><div class="decl" id="Relation.ReflGen"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L264-L268">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen"><span class="name">Relation</span>.<span class="name">ReflGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></div></div><p><code><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> r</code>: reflexive closure of <code>r</code></p><ul class="constructors"><li class="constructor" id="Relation.ReflGen.refl">refl<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">a</span></span></li><li class="constructor" id="Relation.ReflGen.single">single<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span> : <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></li></ul><details id="instances-for-list-Relation.ReflGen" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.reflGen_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L265-L265">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflGen_iff"><span class="name">Relation</span>.<span class="name">reflGen_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">a✝</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">a✝</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a✝</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">a✝</span></span></div></div></div></div><div class="decl" id="Relation.EqvGen"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L271-L277">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen"><span class="name">Relation</span>.<span class="name">EqvGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></div></div><p><code><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">EqvGen</a> r</code>: equivalence closure of <code>r</code>.</p><ul class="constructors"><li class="constructor" id="Relation.EqvGen.rel">rel<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">EqvGen</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span></span></li><li class="constructor" id="Relation.EqvGen.refl">refl<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">EqvGen</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">x</span></span></li><li class="constructor" id="Relation.EqvGen.symm">symm<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">EqvGen</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">EqvGen</a> <span class="fn">r</span> <span class="fn">y</span> <span class="fn">x</span></span></span></li><li class="constructor" id="Relation.EqvGen.trans">trans<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x </span><span class="fn">y </span><span class="fn">z</span> : <span class="fn">α</span>)</span></span>
 : <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">EqvGen</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">EqvGen</a> <span class="fn">r</span> <span class="fn">y</span> <span class="fn">z</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">EqvGen</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">z</span></span></span></span></li></ul><details id="instances-for-list-Relation.EqvGen" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.eqvGen_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L272-L272">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.eqvGen_iff"><span class="name">Relation</span>.<span class="name">eqvGen_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a✝ </span><span class="fn">a✝¹</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">EqvGen</a> <span class="fn">r</span> <span class="fn">a✝</span> <span class="fn">a✝¹</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">r</span> <span class="fn">a✝</span> <span class="fn">a✝¹</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn">a✝¹</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a✝</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">EqvGen</a> <span class="fn">r</span> <span class="fn">a✝¹</span> <span class="fn">a✝</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">y</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">EqvGen</a> <span class="fn">r</span> <span class="fn">a✝</span> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">EqvGen</a> <span class="fn">r</span> <span class="fn">y</span> <span class="fn">a✝¹</span></span></div></div></div></div><div class="decl" id="Relation.transGen_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L279-L279">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transGen_iff"><span class="name">Relation</span>.<span class="name">transGen_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Sort</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a✝ </span><span class="fn">a✝¹</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a✝</span> <span class="fn">a✝¹</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">r</span> <span class="fn">a✝</span> <span class="fn">a✝¹</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a✝</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">a✝¹</span></span></div></div></div></div><div class="decl" id="Relation.ReflGen.to_reflTransGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L284-L286">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen.to_reflTransGen"><span class="name">Relation</span>.<span class="name">ReflGen</span>.<span class="name">to_reflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Relation.ReflGen.mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L288-L290">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen.mono"><span class="name">Relation</span>.<span class="name">ReflGen</span>.<span class="name">mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r </span><span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Relation.ReflGen.instIsRefl"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L292-L293">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen.instIsRefl"><span class="name">Relation</span>.<span class="name">ReflGen</span>.<span class="name">instIsRefl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#IsRefl">IsRefl</a> <span class="fn">α</span> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L299-L303">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.trans"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hbc</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.single"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L305-L306">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.single"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">single</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.head"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L308-L311">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.head"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">head</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hbc</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.symmetric"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L313-L317">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.symmetric"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">symmetric</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.cases_tail"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L319-L320">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.cases_tail"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_tail</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">c</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">c</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.head_induction_on"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L322-L332">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.head_induction_on"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">head_induction_on</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">refl</span> : <span class="fn"><span class="fn">motive</span> <span class="fn">b</span> <span class="fn">⋯</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">head</span> : <span class="fn">∀ {<span class="fn">a </span><span class="fn">c</span> : <span class="fn">α</span>} (<span class="fn">h'</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span>) (<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">c</span> <span class="fn">h</span></span> → <span class="fn"><span class="fn">motive</span> <span class="fn">a</span> <span class="fn">⋯</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">a</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.trans_induction_on"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L334-L342">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.trans_induction_on"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">trans_induction_on</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>} → <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">refl</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">motive</span> <span class="fn">⋯</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">single</span> : <span class="fn">∀ {<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>} (<span class="fn">h</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">motive</span> <span class="fn">⋯</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">trans</span> : <span class="fn">∀ {<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>} (<span class="fn">h₁</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>) (<span class="fn">h₂</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>), <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">h₁</span></span> → <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">h₂</span></span> → <span class="fn"><span class="fn">motive</span> <span class="fn">⋯</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.cases_head"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L344-L345">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.cases_head"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_head</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">c</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.cases_head_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L347-L351">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.cases_head_iff"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">cases_head_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Or">∨</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">c</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.total_of_right_unique"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L353-L363">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.total_of_right_unique"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">total_of_right_unique</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">U</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relator.html#Relator.RightUnique">Relator.RightUnique</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ab</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ac</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.to_reflTransGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L369-L372">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.to_reflTransGen"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">to_reflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.trans_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L374-L377">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.trans_left"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hbc</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.head'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L381-L382">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.head'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hbc</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.tail'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L384-L387">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.tail'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">tail'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hbc</span> : <span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.head"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L389-L390">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.head"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hbc</span> : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.head_induction_on"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L392-L402">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.head_induction_on"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head_induction_on</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">single</span> : <span class="fn">∀ {<span class="fn">a</span> : <span class="fn">α</span>} (<span class="fn">h</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">motive</span> <span class="fn">a</span> <span class="fn">⋯</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">head</span> : <span class="fn">∀ {<span class="fn">a </span><span class="fn">c</span> : <span class="fn">α</span>} (<span class="fn">h'</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span>) (<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">c</span> <span class="fn">h</span></span> → <span class="fn"><span class="fn">motive</span> <span class="fn">a</span> <span class="fn">⋯</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">a</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.trans_induction_on"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L404-L412">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.trans_induction_on"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans_induction_on</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>} → <span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <a href="../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">single</span> : <span class="fn">∀ {<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>} (<span class="fn">h</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>), <span class="fn"><span class="fn">motive</span> <span class="fn">⋯</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">trans</span> : <span class="fn">∀ {<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>} (<span class="fn">h₁</span> : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>) (<span class="fn">h₂</span> : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>), <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">h₁</span></span> → <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">h₂</span></span> → <span class="fn"><span class="fn">motive</span> <span class="fn">⋯</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.trans_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L414-L417">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.trans_right"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">trans_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hbc</span> : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.tail'_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L419-L423">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.tail'_iff"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">tail'_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.head'_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L425-L431">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.head'_iff"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">head'_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">b</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Relation.reflGen_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L438-L440">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflGen_eq_self"><span class="name">Relation</span>.<span class="name">reflGen_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hr</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></div></div></div></div><div class="decl" id="Relation.reflexive_reflGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L442-L442">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflexive_reflGen"><span class="name">Relation</span>.<span class="name">reflexive_reflGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.reflGen_minimal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L444-L446">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflGen_minimal"><span class="name">Relation</span>.<span class="name">reflGen_minimal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r </span><span class="fn">r'</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hr'</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r'</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hxy</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r'</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="Relation.instIsTransTransGen"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L452-L453">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.instIsTransTransGen"><span class="name">Relation</span>.<span class="name">instIsTransTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#IsTrans">IsTrans</a> <span class="fn">α</span> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.instTransTransGen_mathlib"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L455-L456">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.instTransTransGen_mathlib"><span class="name">Relation</span>.<span class="name">instTransTransGen_mathlib</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Trans">Trans</a> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span>)</span> <span class="fn">r</span> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Logic/Relation.html#Relation.instTransTransGen_mathlib">Relation.instTransTransGen_mathlib</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Trans.mk">{</a> <span class="fn">trans</span> := <span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Trans.mk">}</a></li></ul></details></div></div><div class="decl" id="Relation.instTransTransGen_mathlib_1"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L458-L459">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.instTransTransGen_mathlib_1"><span class="name">Relation</span>.<span class="name">instTransTransGen_mathlib_1</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Trans">Trans</a> <span class="fn">r</span> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span>)</span> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Logic/Relation.html#Relation.instTransTransGen_mathlib_1">Relation.instTransTransGen_mathlib_1</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Trans.mk">{</a> <span class="fn">trans</span> := <span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Trans.mk">}</a></li></ul></details></div></div><div class="decl" id="Relation.instTransTransGenReflTransGen"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L461-L462">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.instTransTransGenReflTransGen"><span class="name">Relation</span>.<span class="name">instTransTransGenReflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Trans">Trans</a> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span>)</span> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span>)</span> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Logic/Relation.html#Relation.instTransTransGenReflTransGen">Relation.instTransTransGenReflTransGen</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Trans.mk">{</a> <span class="fn">trans</span> := <span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Trans.mk">}</a></li></ul></details></div></div><div class="decl" id="Relation.instTransReflTransGenTransGen"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L464-L465">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.instTransReflTransGenTransGen"><span class="name">Relation</span>.<span class="name">instTransReflTransGenTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Trans">Trans</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span>)</span> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span>)</span> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Logic/Relation.html#Relation.instTransReflTransGenTransGen">Relation.instTransReflTransGenTransGen</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Trans.mk">{</a> <span class="fn">trans</span> := <span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Trans.mk">}</a></li></ul></details></div></div><div class="decl" id="Relation.transGen_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L467-L472">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transGen_eq_self"><span class="name">Relation</span>.<span class="name">transGen_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">trans</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></div></div></div></div><div class="decl" id="Relation.transitive_transGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L474-L474">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transitive_transGen"><span class="name">Relation</span>.<span class="name">transitive_transGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.transGen_idem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L476-L477">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transGen_idem"><span class="name">Relation</span>.<span class="name">transGen_idem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.lift"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L479-L483">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.lift"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">lift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.lift'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L485-L488">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.lift'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">lift'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.closed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L490-L492">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.closed"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">closed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> → <span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Relation.TransGen.closed'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L494-L496">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.closed'"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">closed'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">P</span> : <span class="fn"><span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">dc</span> : <span class="fn">∀ {<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="Relation.TransGen.mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L498-L500">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.mono"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> → <span class="fn"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Relation.transGen_minimal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L502-L504">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transGen_minimal"><span class="name">Relation</span>.<span class="name">transGen_minimal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r </span><span class="fn">r'</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hr'</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">r'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r'</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hxy</span> : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r'</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="Relation.TransGen.swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L506-L509">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.TransGen.swap"><span class="name">Relation</span>.<span class="name">TransGen</span>.<span class="name">swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">r</span>)</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.transGen_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L511-L512">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transGen_swap"><span class="name">Relation</span>.<span class="name">transGen_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">r</span>)</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_iff_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L520-L521">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_iff_eq"><span class="name">Relation</span>.<span class="name">reflTransGen_iff_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Relation.reflTransGen_iff_eq_or_transGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L523-L530">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_iff_eq_or_transGen"><span class="name">Relation</span>.<span class="name">reflTransGen_iff_eq_or_transGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">b</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.lift"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L532-L534">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.lift"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">lift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L536-L538">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.mono"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L540-L545">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_eq_self"><span class="name">Relation</span>.<span class="name">reflTransGen_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">refl</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">trans</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></div></div></div></div><div class="decl" id="Relation.reflTransGen_minimal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L547-L549">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_minimal"><span class="name">Relation</span>.<span class="name">reflTransGen_minimal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r </span><span class="fn">r'</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hr₁</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hr₂</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">r'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">r'</span> <span class="fn">x</span> <span class="fn">y</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">y</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hxy</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r'</span> <span class="fn">x</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="Relation.reflexive_reflTransGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L551-L551">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflexive_reflTransGen"><span class="name">Relation</span>.<span class="name">reflexive_reflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.transitive_reflTransGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L553-L553">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transitive_reflTransGen"><span class="name">Relation</span>.<span class="name">transitive_reflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.instTransReflTransGen"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L555-L556">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.instTransReflTransGen"><span class="name">Relation</span>.<span class="name">instTransReflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Trans">Trans</a> <span class="fn">r</span> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span>)</span> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Logic/Relation.html#Relation.instTransReflTransGen">Relation.instTransReflTransGen</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Trans.mk">{</a> <span class="fn">trans</span> := <span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Trans.mk">}</a></li></ul></details></div></div><div class="decl" id="Relation.instTransReflTransGen_1"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L558-L559">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.instTransReflTransGen_1"><span class="name">Relation</span>.<span class="name">instTransReflTransGen_1</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Trans">Trans</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span>)</span> <span class="fn">r</span> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../.././Mathlib/Logic/Relation.html#Relation.instTransReflTransGen_1">Relation.instTransReflTransGen_1</a> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Trans.mk">{</a> <span class="fn">trans</span> := <span class="fn">⋯</span> <a href="../.././Init/Prelude.html#Trans.mk">}</a></li></ul></details></div></div><div class="decl" id="Relation.instIsReflReflTransGen"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L561-L562">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.instIsReflReflTransGen"><span class="name">Relation</span>.<span class="name">instIsReflReflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#IsRefl">IsRefl</a> <span class="fn">α</span> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.instIsTransReflTransGen"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L564-L565">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.instIsTransReflTransGen"><span class="name">Relation</span>.<span class="name">instIsTransReflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#IsTrans">IsTrans</a> <span class="fn">α</span> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_idem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L567-L568">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_idem"><span class="name">Relation</span>.<span class="name">reflTransGen_idem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.lift'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L570-L573">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.lift'"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">lift'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">p</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_closed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L575-L577">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_closed"><span class="name">Relation</span>.<span class="name">reflTransGen_closed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Relation.ReflTransGen.swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L579-L582">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen.swap"><span class="name">Relation</span>.<span class="name">ReflTransGen</span>.<span class="name">swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">r</span>)</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L584-L585">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_swap"><span class="name">Relation</span>.<span class="name">reflTransGen_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">r</span>)</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Relation.reflGen_transGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L587-L589">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflGen_transGen"><span class="name">Relation</span>.<span class="name">reflGen_transGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.transGen_reflGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L591-L598">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transGen_reflGen"><span class="name">Relation</span>.<span class="name">transGen_reflGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> <span class="fn">r</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_reflGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L600-L601">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_reflGen"><span class="name">Relation</span>.<span class="name">reflTransGen_reflGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> <span class="fn">r</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_transGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L603-L604">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_transGen"><span class="name">Relation</span>.<span class="name">reflTransGen_transGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">(<a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_eq_transGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L606-L608">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_eq_transGen"><span class="name">Relation</span>.<span class="name">reflTransGen_eq_transGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hr</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Core.html#Relation.TransGen">TransGen</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_eq_reflGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L610-L612">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_eq_reflGen"><span class="name">Relation</span>.<span class="name">reflTransGen_eq_reflGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hr</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> <span class="fn">r</span></span></div></div></div></div><div class="decl" id="Relation.EqvGen.is_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L620-L621">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen.is_equivalence"><span class="name">Relation</span>.<span class="name">EqvGen</span>.<span class="name">is_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">EqvGen</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.EqvGen.setoid"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L623-L628">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen.setoid"><span class="name">Relation</span>.<span class="name">EqvGen</span>.<span class="name">setoid</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Setoid">Setoid</a> <span class="fn">α</span></span></div></div><p><code><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen.setoid">EqvGen.setoid</a> r</code> is the setoid generated by a relation <code>r</code>.</p><p>The motivation for this definition is that <code><a href="../.././Init/Prelude.html#Quot">Quot</a> r</code> behaves like <code><a href="../.././Init/Core.html#Quotient">Quotient</a> (EqvGen.<a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen.setoid">setoid</a> r)</code>,
see for example <code><a href="../.././Mathlib/Logic/Relation.html#Quot.eqvGen_exact">Quot.eqvGen_exact</a></code> and <code><a href="../.././Mathlib/Logic/Relation.html#Quot.eqvGen_sound">Quot.eqvGen_sound</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen.setoid">Relation.EqvGen.setoid</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Core.html#Setoid.mk">{</a> <span class="fn">r</span> := <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span></span>, <span class="fn">iseqv</span> := <span class="fn">⋯</span> <a href="../.././Init/Core.html#Setoid.mk">}</a></li></ul></details><details id="instances-for-list-Relation.EqvGen.setoid" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.EqvGen.mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L630-L636">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen.mono"><span class="name">Relation</span>.<span class="name">EqvGen</span>.<span class="name">mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r </span><span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hrp</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">EqvGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">EqvGen</a> <span class="fn">p</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.Join"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L640-L647">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.Join"><span class="name">Relation</span>.<span class="name">Join</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span></div></div><p>The join of a relation on a single type is a new relation for which
pairs of terms are related if there is a third term they are both
related to.  For example, if <code>r</code> is a relation representing rewrites
in a term rewriting system, then <em>confluence</em> is the property that if
<code>a</code> rewrites to both <code>b</code> and <code>c</code>, then <code>join r</code> relates <code>b</code> and <code>c</code>
(see <code><a href="../.././Mathlib/Logic/Relation.html#Relation.church_rosser">Relation.church_rosser</a></code>).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Relation.Join</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">c</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span></li></ul></details><details id="instances-for-list-Relation.Join" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.church_rosser"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L653-L674">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.church_rosser"><span class="name">Relation</span>.<span class="name">church_rosser</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> → <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">d</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">d</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">d</span></span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hac</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Join</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span>)</span> <span class="fn">b</span> <span class="fn">c</span></span></div></div><p>A sufficient condition for the Church-Rosser property.</p></div></div><div class="decl" id="Relation.join_of_single"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L677-L678">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.join_of_single"><span class="name">Relation</span>.<span class="name">join_of_single</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Join</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.symmetric_join"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L680-L680">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.symmetric_join"><span class="name">Relation</span>.<span class="name">symmetric_join</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Symmetric">Symmetric</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Join</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.reflexive_join"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L682-L682">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflexive_join"><span class="name">Relation</span>.<span class="name">reflexive_join</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Join</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.transitive_join"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L684-L688">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.transitive_join"><span class="name">Relation</span>.<span class="name">transitive_join</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Join</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Join</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.equivalence_join"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L690-L692">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.equivalence_join"><span class="name">Relation</span>.<span class="name">equivalence_join</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hr</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> → <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Join</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">c</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Join</a> <span class="fn">r</span>)</span></span></div></div></div></div><div class="decl" id="Relation.equivalence_join_reflTransGen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L694-L697">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.equivalence_join_reflTransGen"><span class="name">Relation</span>.<span class="name">equivalence_join_reflTransGen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">c</span></span> → <a href="../.././Init/Core.html#Exists">∃</a> <a href="../.././Init/Core.html#Exists">(</a><span class="fn">d</span> <a href="../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../.././Init/Core.html#Exists">)</a><a href="../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflGen">ReflGen</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">d</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span> <span class="fn">c</span> <span class="fn">d</span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Join</a> <span class="fn">(<a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r</span>)</span>)</span></span></div></div></div></div><div class="decl" id="Relation.join_of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L699-L701">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.join_of_equivalence"><span class="name">Relation</span>.<span class="name">join_of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r'</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hr</span> : <span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r'</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Join">Join</a> <span class="fn">r'</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_of_transitive_reflexive"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L703-L707">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_of_transitive_reflexive"><span class="name">Relation</span>.<span class="name">reflTransGen_of_transitive_reflexive</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r'</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hr</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Reflexive">Reflexive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ht</span> : <span class="fn"><a href="../.././Mathlib/Order/Defs/Unbundled.html#Transitive">Transitive</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r'</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r'</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Relation.reflTransGen_of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L709-L711">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Relation.reflTransGen_of_equivalence"><span class="name">Relation</span>.<span class="name">reflTransGen_of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r'</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hr</span> : <span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><span class="fn">r'</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen">ReflTransGen</a> <span class="fn">r'</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span></div></div></div></div><div class="decl" id="Quot.eqvGen_exact"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L723-L725">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Quot.eqvGen_exact"><span class="name">Quot</span>.<span class="name">eqvGen_exact</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../.././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Quot.eqvGen_sound"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L727-L733">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Quot.eqvGen_sound"><span class="name">Quot</span>.<span class="name">eqvGen_sound</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">H</span> : <span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Quot.mk">mk</a> <span class="fn">r</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Equivalence.eqvGen_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L735-L744">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Equivalence.eqvGen_iff"><span class="name">Equivalence</span>.<span class="name">eqvGen_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Equivalence.eqvGen_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Logic/Relation.lean#L746-L747">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Relation.html#Equivalence.eqvGen_eq"><span class="name">Equivalence</span>.<span class="name">eqvGen_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.EqvGen">Relation.EqvGen</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></div></div></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>