<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Tactic.Ring.Basic</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Tactic.Ring.Basic";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">Basic</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Util/AtomM.html">Mathlib.Util.AtomM</a></li><li><a href="../../.././Mathlib/Tactic/NormNum/Inv.html">Mathlib.Tactic.NormNum.Inv</a></li><li><a href="../../.././Mathlib/Tactic/NormNum/Pow.html">Mathlib.Tactic.NormNum.Pow</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Tactic.Ring.Basic" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.instCommSemiringNat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instCommSemiringNat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.sℕ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">sℕ</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExBase"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExSum"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExBase.eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExSum.eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExBase.cmp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">cmp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.cmp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">cmp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExSum.cmp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">cmp</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExBase"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instInhabitedSigmaQuotedExBase</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExSum"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instInhabitedSigmaQuotedExSum</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instInhabitedSigmaQuotedExProd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExBase.cast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">cast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.cast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">cast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExSum.cast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">cast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.Result"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">Result</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.instInhabitedResultOfSigmaQuoted"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instInhabitedResultOfSigmaQuoted</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.mkNat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">mkNat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.mkNegNat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">mkNegNat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.mkNNRat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">mkNNRat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.mkNegNNRat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">mkNegNNRat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExBase.toProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.toSum"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">toSum</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.coeff"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">coeff</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.Overlap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">Overlap</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_overlap_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_overlap_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_overlap_pf_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_overlap_pf_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalAddOverlap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalAddOverlap</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_pf_zero_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_zero_add</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_pf_add_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_add_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_pf_add_overlap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_add_overlap</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_pf_add_overlap_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_add_overlap_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_pf_add_lt"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_add_lt</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_pf_add_gt"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_add_gt</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalAdd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalAdd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.one_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">one_mul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.mul_one"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_one</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.mul_pf_left"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_pf_left</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.mul_pf_right"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_pf_right</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.mul_pp_pf_overlap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_pp_pf_overlap</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalMulProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalMulProd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.mul_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.mul_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_add</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalMul₁"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalMul₁</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.zero_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">zero_mul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_mul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalMul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalMul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.natCast_nat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">natCast_nat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.natCast_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">natCast_mul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.natCast_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">natCast_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.natCast_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">natCast_add</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExBase.evalNatCast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">evalNatCast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.evalNatCast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">evalNatCast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExSum.evalNatCast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">evalNatCast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.smul_nat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">smul_nat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.smul_eq_cast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">smul_eq_cast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalNSMul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalNSMul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.neg_one_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">neg_one_mul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.neg_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">neg_mul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalNegProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalNegProd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.neg_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">neg_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.neg_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">neg_add</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalNeg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalNeg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.sub_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">sub_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalSub"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalSub</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.pow_prod_atom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_prod_atom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalPowProdAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPowProdAtom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.pow_atom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_atom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalPowAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPowAtom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.const_pos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">const_pos</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.mul_exp_pos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_exp_pos</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_pos_left"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pos_left</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_pos_right"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pos_right</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExBase.evalPos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">evalPos</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.evalPos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">evalPos</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExSum.evalPos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">evalPos</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.pow_one"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_one</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.pow_bit0"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_bit0</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.pow_bit1"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_bit1</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalPowNat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPowNat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.one_pow"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">one_pow</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.mul_pow"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_pow</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalPowProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPowProd</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExtractCoeff"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExtractCoeff</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.coeff_one"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">coeff_one</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.coeff_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">coeff_mul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.extractCoeff"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">extractCoeff</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.pow_one_cast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_one_cast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.zero_pow"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">zero_pow</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.single_pow"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">single_pow</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.pow_nat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_nat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalPow₁"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPow₁</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.pow_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.pow_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_add</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalPow"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPow</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.Cache"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">Cache</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.mkCache"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mkCache</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.cast_pos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">cast_pos</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.cast_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">cast_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.cast_neg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">cast_neg</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.cast_nnrat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">cast_nnrat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.cast_rat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">cast_rat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalCast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalCast</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.toProd_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">toProd_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.atom_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">atom_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.atom_pf'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">atom_pf'</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalAtom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.inv_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">inv_mul</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.inv_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">inv_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.inv_single"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">inv_single</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.inv_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">inv_add</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalInvAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalInvAtom</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExProd.evalInv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">evalInv</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ExSum.evalInv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">evalInv</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.div_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">div_pf</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.evalDiv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalDiv</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.add_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.mul_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.nsmul_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">nsmul_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.pow_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.neg_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">neg_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.sub_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">sub_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.inv_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">inv_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.div_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">div_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.Cache.nat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">Cache</span>.<span class="name">nat</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.isAtomOrDerivable"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">isAtomOrDerivable</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">eval</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.CSLift"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">CSLift</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.CSLiftVal"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">CSLiftVal</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.instCSLiftValLift"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instCSLiftValLift</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.of_lift"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">of_lift</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.of_eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ringCleanupRef"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ringCleanupRef</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.proveEq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">proveEq</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.proveEq.ringCore"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">proveEq</span>.<span class="name">ringCore</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.ring1"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ring1</span></a></div><div class="nav_link"><a class="break_within" href="#Mathlib.Tactic.Ring.tacticRing1!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">tacticRing1!</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="ring-tactic"><code>ring</code> tactic <a class="hover-link" href="#ring-tactic">#</a></h1><p>A tactic for solving equations in commutative (semi)rings,
where the exponents can also contain variables.
Based on <a href="http://www.cs.ru.nl/~freek/courses/tt-2014/read/10.1.1.61.3041.pdf">http://www.cs.ru.nl/~freek/courses/tt-2014/read/10.1.1.61.3041.pdf</a> .</p><p>More precisely, expressions of the following form are supported:</p><ul>
<li>constants (non-negative integers)</li>
<li>variables</li>
<li>coefficients (any rational number, embedded into the (semi)ring)</li>
<li>addition of expressions</li>
<li>multiplication of expressions (<code>a * b</code>)</li>
<li>scalar multiplication of expressions (<code>n • a</code>; the multiplier must have type <code>ℕ</code>)</li>
<li>exponentiation of expressions (the exponent must have type <code>ℕ</code>)</li>
<li>subtraction and negation of expressions (if the base is a full ring)</li>
</ul><p>The extension to exponents means that something like <code>2 * 2^n * b = b * 2^(n+1)</code> can be proved,
even though it is not strictly speaking an equation in the language of commutative rings.</p><h2 class="markdown-heading" id="Implementation-notes">Implementation notes <a class="hover-link" href="#Implementation-notes">#</a></h2><p>The basic approach to prove equalities is to normalise both sides and check for equality.
The normalisation is guided by building a value in the type <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a></code> at the meta level,
together with a proof (at the base level) that the original value is equal to
the normalised version.</p><p>The outline of the file:</p><ul>
<li>Define a mutual inductive family of types <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a></code>, <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a></code>, <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a></code>,
which can represent expressions with <code>+</code>, <code>*</code>, <code>^</code> and rational numerals.
The mutual induction ensures that associativity and distributivity are applied,
by restricting which kinds of subexpressions appear as arguments to the various operators.</li>
<li>Represent addition, multiplication and exponentiation in the <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a></code> type,
thus allowing us to map expressions to <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a></code> (the <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.eval">eval</a></code> function drives this).
We apply associativity and distributivity of the operators here (helped by <code>Ex*</code> types)
and commutativity as well (by sorting the subterms; unfortunately not helped by anything).
Any expression not of the above formats is treated as an atom (the same as a variable).</li>
</ul><p>There are some details we glossed over which make the plan more complicated:</p><ul>
<li>The order on atoms is not initially obvious.
We construct a list containing them in order of initial appearance in the expression,
then use the index into the list as a key to order on.</li>
<li>For <code>pow</code>, the exponent must be a natural number, while the base can be any semiring <code>α</code>.
We swap out operations for the base ring <code>α</code> with those for the exponent ring <code>ℕ</code>
as soon as we deal with exponents.</li>
</ul><h2 class="markdown-heading" id="Caveats-and-future-work">Caveats and future work <a class="hover-link" href="#Caveats-and-future-work">#</a></h2><p>The normalized form of an expression is the one that is useful for the tactic,
but not as nice to read. To remedy this, the user-facing normalization calls <code>ringNFCore</code>.</p><p>Subtraction cancels out identical terms, but division does not.
That is: <code>a - a = 0 := by ring</code> solves the goal,
but <code>a / a := 1 by ring</code> doesn't.
Note that <code>0 / 0</code> is generally defined to be <code>0</code>,
so division cancelling out is not true in general.</p><p>Multiplication of powers can be simplified a little bit further:
<code>2 ^ n * 2 ^ n = 4 ^ n := by ring</code> could be implemented
in a similar way that <code>2 * a + 2 * a = 4 * a := by ring</code> already works.
This feature wasn't needed yet, so it's not implemented yet.</p><h2 class="markdown-heading" id="Tags">Tags <a class="hover-link" href="#Tags">#</a></h2><p>ring, semiring, exponent, power</p></div><div class="decl" id="Mathlib.Tactic.Ring.instCommSemiringNat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L88-L89">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCommSemiringNat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instCommSemiringNat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a></span></div></div><p>A shortcut instance for <code><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> ℕ</code> used by ring.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCommSemiringNat">Mathlib.Tactic.Ring.instCommSemiringNat</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#inferInstance">inferInstance</a></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.instCommSemiringNat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.sℕ"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L91-L95">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">sℕ</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a></span>)</span></div></div><p>A typed expression of type <code><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> ℕ</code> used when we are working on
ring subexpressions of type <code>ℕ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">Mathlib.Tactic.Ring.sℕ</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">q(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCommSemiringNat">Mathlib.Tactic.Ring.instCommSemiringNat</a>)</span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.sℕ" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExBase"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L99-L115">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span> → <span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>) → <a href="../../.././foundational_types.html">Type</a></span></span></div></div><p>The base <code>e</code> of a normalized exponent expression.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.Ring.ExBase.atom">atom<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">id</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
 : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a> <span class="fn">sα</span> <span class="fn">e</span></span><div class="inductive_ctor_doc"><p>An atomic expression <code>e</code> with id <code><a href="../../.././Init/Prelude.html#id">id</a></code>.</p><p>Atomic expressions are those which <code>ring</code> cannot parse any further.
For instance, <code>a + (a % b)</code> has <code>a</code> and <code>(a % b)</code> as atoms.
The <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ring1">ring1</a></code> tactic does not normalize the subexpressions in atoms, but <code>ring_nf</code> does.</p><p>Atoms in fact represent equivalence classes of expressions, modulo definitional equality.
The field <code>index : ℕ</code> should be a unique number for each class,
while <code>value : <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.expr">expr</a></code> contains a representative of this class.
The function <code>resolve_atom</code> determines the appropriate atom for a given expression.</p></div></li><li class="constructor" id="Mathlib.Tactic.Ring.ExBase.sum">sum<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">e</span></span> → <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a> <span class="fn">sα</span> <span class="fn">e</span></span></span><div class="inductive_ctor_doc"><p>A sum of monomials.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Ring.ExBase" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L117-L129">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span> → <span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>) → <a href="../../.././foundational_types.html">Type</a></span></span></div></div><p>A monomial, which is a product of powers of <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a></code> expressions,
terminated by a (nonzero) constant coefficient.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.Ring.ExProd.const">const<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">value</span> : <a href="../../.././Batteries/Data/Rat/Basic.html#Rat">ℚ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hyp</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span> := <a href="../../.././Init/Prelude.html#Option.none">none</a>)</span></span>
 : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">e</span></span><div class="inductive_ctor_doc"><p>A coefficient <code>value</code>, which must not be <code>0</code>. <code>e</code> is a raw rat cast.
If <code>value</code> is not an integer, then <code>hyp</code> should be a proof of <code>(value.den : α) ≠ 0</code>.</p></div></li><li class="constructor" id="Mathlib.Tactic.Ring.ExProd.mul">mul<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a> <span class="fn">sα</span> <span class="fn">x</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">sℕ</a> <span class="fn">e</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">b</span></span> → <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">q(<span class="fn">«$x»</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$e»</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">«$b»</span>)</span></span></span></span></span><div class="inductive_ctor_doc"><p>A product <code>x ^ e * b</code> is a monomial if <code>b</code> is a monomial. Here <code>x</code> is an <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a></code>
and <code>e</code> is an <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a></code> representing a monomial expression in <code>ℕ</code> (it is a monomial instead of
a polynomial because we eagerly normalize <code>x ^ (a + b) = x ^ a * x ^ b</code>.)</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Ring.ExProd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExSum"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L131-L137">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span> → <span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>) → <a href="../../.././foundational_types.html">Type</a></span></span></div></div><p>A polynomial expression, which is a sum of monomials.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.Ring.ExSum.zero">zero<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">q(<span class="fn">0</span>)</span></span><div class="inductive_ctor_doc"><p>Zero is a polynomial. <code>e</code> is the expression <code>0</code>.</p></div></li><li class="constructor" id="Mathlib.Tactic.Ring.ExSum.add">add<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">b</span></span> → <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">q(<span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">«$b»</span>)</span></span></span></span><div class="inductive_ctor_doc"><p>A sum <code>a + b</code> is a polynomial if <code>a</code> is a monomial and <code>b</code> is another polynomial.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Ring.ExSum" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExBase.eq"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L142-L148">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a> <span class="fn">sα</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a> <span class="fn">sα</span> <span class="fn">b</span></span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span></div></div><p>Equality test for expressions. This is not a <code><a href="../../.././Init/Prelude.html#BEq">BEq</a></code> instance because it is heterogeneous.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.eq"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L150-L156">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">b</span></span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span></div></div><p>Equality test for expressions. This is not a <code><a href="../../.././Init/Prelude.html#BEq">BEq</a></code> instance because it is heterogeneous.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExSum.eq"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L158-L164">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">b</span></span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></span></div></div><p>Equality test for expressions. This is not a <code><a href="../../.././Init/Prelude.html#BEq">BEq</a></code> instance because it is heterogeneous.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExBase.cmp"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L168-L178">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.cmp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">cmp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a> <span class="fn">sα</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a> <span class="fn">sα</span> <span class="fn">b</span></span> → <a href="../../.././Init/Data/Ord.html#Ordering">Ordering</a></span></span></div></div><p>A total order on normalized expressions.
This is not an <code><a href="../../.././Init/Data/Ord.html#Ord">Ord</a></code> instance because it is heterogeneous.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.cmp"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L180-L187">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.cmp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">cmp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">b</span></span> → <a href="../../.././Init/Data/Ord.html#Ordering">Ordering</a></span></span></div></div><p>A total order on normalized expressions.
This is not an <code><a href="../../.././Init/Data/Ord.html#Ord">Ord</a></code> instance because it is heterogeneous.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExSum.cmp"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L189-L196">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.cmp"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">cmp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">b</span></span> → <a href="../../.././Init/Data/Ord.html#Ordering">Ordering</a></span></span></div></div><p>A total order on normalized expressions.
This is not an <code><a href="../../.././Init/Data/Ord.html#Ord">Ord</a></code> instance because it is heterogeneous.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExBase"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L201-L201">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExBase"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instInhabitedSigmaQuotedExBase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">((<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>) × <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a> <span class="fn">sα</span> <span class="fn">e</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExBase">Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExBase</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../.././Init/Core.html#Sigma.mk">⟨</a><a href="../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.atom">Mathlib.Tactic.Ring.ExBase.atom</a> <span class="fn">0</span></span><a href="../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExSum"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L202-L202">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExSum"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instInhabitedSigmaQuotedExSum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">((<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>) × <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">e</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExSum">Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExSum</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">q(<span class="fn">0</span>)</span>, <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.zero">Mathlib.Tactic.Ring.ExSum.zero</a><a href="../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExProd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L203-L203">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instInhabitedSigmaQuotedExProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">((<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>) × <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">e</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExProd">Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExProd</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../.././Init/Core.html#Sigma.mk">⟨</a><a href="../../.././Init/Prelude.html#Inhabited.default">default</a>, <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">Mathlib.Tactic.Ring.ExProd.const</a> <span class="fn">0</span></span><a href="../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExBase.cast"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L207-L212">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.cast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">cast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sβ</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$β»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a> <span class="fn">sα</span> <span class="fn">a</span></span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">Q(<span class="fn">«$β»</span>)</span>) × <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a> <span class="fn">sβ</span> <span class="fn">a</span></span></span></span></div></div><p>Converts <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a> sα</code> to <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a> sβ</code>, assuming <code>sα</code> and <code>sβ</code> are defeq.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.cast"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L214-L219">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.cast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">cast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sβ</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$β»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">a</span></span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">Q(<span class="fn">«$β»</span>)</span>) × <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sβ</span> <span class="fn">a</span></span></span></span></div></div><p>Converts <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> sα</code> to <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> sβ</code>, assuming <code>sα</code> and <code>sβ</code> are defeq.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExSum.cast"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L221-L226">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.cast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">cast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sβ</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$β»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">Q(<span class="fn">«$β»</span>)</span>) × <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sβ</span> <span class="fn">a</span></span></span></span></div></div><p>Converts <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> sα</code> to <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> sβ</code>, assuming <code>sα</code> and <code>sβ</code> are defeq.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.Result"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L232-L243">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">Result</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">E</span> : <span class="fn"><span class="fn">Q(<span class="fn">«$α»</span>)</span> → <a href="../../.././foundational_types.html">Type</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>The result of evaluating an (unnormalized) expression <code>e</code> into the type family <code>E</code>
(one of <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a></code>, <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a></code>, <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a></code>) is a (normalized) element <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.e'">e'</a></code>
and a representation <code>E <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.e'">e'</a></code> for it, and a proof of <code>e = <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.e'">e'</a></code>.</p><ul class="structure_fields" id="Mathlib.Tactic.Ring.Result.mk"><li id="Mathlib.Tactic.Ring.Result.expr" class="structure_field"><div class="structure_field_info">expr : <span class="fn">Q(<span class="fn">«$α»</span>)</span></div><div class="structure_field_doc"><p>The normalized result.</p></div></li><li id="Mathlib.Tactic.Ring.Result.val" class="structure_field"><div class="structure_field_info">val : <span class="fn"><span class="fn">E</span> <span class="fn"><span class="fn">self</span>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.expr">expr</a></span></span></div><div class="structure_field_doc"><p>The data associated to the normalization.</p></div></li><li id="Mathlib.Tactic.Ring.Result.proof" class="structure_field"><div class="structure_field_info">proof : <span class="fn">Q(<span class="fn">«$e»</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">unknown_1</span>)</span></div><div class="structure_field_doc"><p>A proof that the original expression is equal to the normalized result.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Ring.Result" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.instInhabitedResultOfSigmaQuoted"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L245-L247">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedResultOfSigmaQuoted"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instInhabitedResultOfSigmaQuoted</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">E</span> : <span class="fn"><span class="fn">Q(<span class="fn">«$α»</span>)</span> → <a href="../../.././foundational_types.html">Type</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">((<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>) × <span class="fn"><span class="fn">E</span> <span class="fn">e</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">E</span> <span class="fn">e</span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedResultOfSigmaQuoted">Mathlib.Tactic.Ring.instInhabitedResultOfSigmaQuoted</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <a href="../../.././Init/Prelude.html#Inhabited.default">default</a> with
  | <a href="../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">e'</span>, <span class="fn">v</span><a href="../../.././Init/Core.html#Sigma.mk">⟩</a> =&gt; <a href="../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk">{</a> <span class="fn">expr</span> := <span class="fn">e'</span>, <span class="fn">val</span> := <span class="fn">v</span>, <span class="fn">proof</span> := <a href="../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk">}</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">}</a></span></li></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.mkNat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L251-L257">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">mkNat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>) × <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">e</span></span></span></div></div><p>Constructs the expression corresponding to <code>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">const</a> n</code>.
(The <code>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">const</a></code> constructor does not check that the expression is correct.)</p><details id="instances-for-list-Mathlib.Tactic.Ring.ExProd.mkNat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.mkNegNat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L259-L265">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNegNat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">mkNegNat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">«$α»</span></span>)</span> → <span class="fn">(<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>) → <span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>) × <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">e</span></span></span></span></span></div></div><p>Constructs the expression corresponding to <code>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">const</a> (-n)</code>.
(The <code>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">const</a></code> constructor does not check that the expression is correct.)</p><details id="instances-for-list-Mathlib.Tactic.Ring.ExProd.mkNegNat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.mkNNRat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L267-L274">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNNRat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">mkNNRat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionSemiring">DivisionSemiring</a> <span class="fn">«$α»</span></span>)</span> → <span class="fn">(<span class="fn">q</span> : <a href="../../.././Batteries/Data/Rat/Basic.html#Rat">ℚ</a>) → <span class="fn">(<span class="fn">n </span><span class="fn">d</span> : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>) → <span class="fn">(<span class="fn">h</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>) → <span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>) × <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">e</span></span></span></span></span></span></span></div></div><p>Constructs the expression corresponding to <code>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">const</a> q h</code> for <code>q = n / d</code>
and <code>h</code> a proof that <code>(d : α) ≠ 0</code>.
(The <code>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">const</a></code> constructor does not check that the expression is correct.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNNRat">Mathlib.Tactic.Ring.ExProd.mkNNRat</a> <span class="fn">sα</span> <span class="fn">x✝</span> <span class="fn">q</span> <span class="fn">n</span> <span class="fn">d</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">q(<span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#NNRat.rawCast">NNRat.rawCast</a> <span class="fn">«$n»</span> <span class="fn">«$d»</span></span>)</span>, <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">Mathlib.Tactic.Ring.ExProd.const</a> <span class="fn">q</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">h</span>)</span></span><a href="../../.././Init/Core.html#Sigma.mk">⟩</a></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.ExProd.mkNNRat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.mkNegNNRat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L276-L283">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNegNNRat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">mkNegNNRat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">«$α»</span></span>)</span> → <span class="fn">(<span class="fn">q</span> : <a href="../../.././Batteries/Data/Rat/Basic.html#Rat">ℚ</a>) → <span class="fn">(<span class="fn">n </span><span class="fn">d</span> : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>) → <span class="fn">(<span class="fn">h</span> : <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a>) → <span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>) × <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">e</span></span></span></span></span></span></span></div></div><p>Constructs the expression corresponding to <code>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">const</a> q h</code> for <code>q = -(n / d)</code>
and <code>h</code> a proof that <code>(d : α) ≠ 0</code>.
(The <code>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">const</a></code> constructor does not check that the expression is correct.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNegNNRat">Mathlib.Tactic.Ring.ExProd.mkNegNNRat</a> <span class="fn">sα</span> <span class="fn">x✝</span> <span class="fn">q</span> <span class="fn">n</span> <span class="fn">d</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">q(<span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Rat.rawCast">Rat.rawCast</a> <span class="fn">(<a href="../../.././Init/Data/Int/Basic.html#Int.negOfNat">Int.negOfNat</a> <span class="fn">«$n»</span>)</span> <span class="fn">«$d»</span></span>)</span>, <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">Mathlib.Tactic.Ring.ExProd.const</a> <span class="fn">q</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">h</span>)</span></span><a href="../../.././Init/Core.html#Sigma.mk">⟩</a></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.ExProd.mkNegNNRat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExBase.toProd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L287-L290">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.toProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">vb</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">sℕ</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">q(<span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$b»</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span>)</span></span></div></div><p>Embed an exponent (an <code>ExBase, <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a></code> pair) as an <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a></code> by multiplying by 1.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><span class="fn">va</span>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.toProd">toProd</a></span> <span class="fn">vb</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mul">Mathlib.Tactic.Ring.ExProd.mul</a> <span class="fn">va</span> <span class="fn">vb</span> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">Mathlib.Tactic.Ring.ExProd.const</a> <span class="fn">1</span>)</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.ExBase.toProd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.toSum"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L292-L294">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.toSum"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">toSum</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">e</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">q(<span class="fn">«$e»</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span>)</span></span></div></div><p>Embed <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a></code> in <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a></code> by adding 0.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">v</span>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.toSum">toSum</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.add">Mathlib.Tactic.Ring.ExSum.add</a> <span class="fn">v</span> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.zero">Mathlib.Tactic.Ring.ExSum.zero</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.ExProd.toSum" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.coeff"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L296-L299">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.coeff"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">coeff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">e</span></span> → <a href="../../.././Batteries/Data/Rat/Basic.html#Rat">ℚ</a></span></div></div><p>Get the leading coefficient of an <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const">Mathlib.Tactic.Ring.ExProd.const</a> <span class="fn">i</span> <span class="fn">h</span>)</span>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.coeff">coeff</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">i</span></li><li class="equation"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mul">Mathlib.Tactic.Ring.ExProd.mul</a> <span class="fn">a₁</span> <span class="fn">a₂</span> <span class="fn">a₃</span>)</span>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.coeff">coeff</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">a₃</span>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.coeff">coeff</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.ExProd.coeff" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.Overlap"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L302-L312">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">Overlap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>Two monomials are said to &quot;overlap&quot; if they differ by a constant factor, in which case the
constants just add. When this happens, the constant may be either zero (if the monomials cancel)
or nonzero (if they add up); the zero case is handled specially.</p><ul class="constructors"><li class="constructor" id="Mathlib.Tactic.Ring.Overlap.zero">zero<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span> : <span class="fn"><span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat">Meta.NormNum.IsNat</a> <span class="fn">«$e»</span> <span class="fn">0</span></span>)</span> → <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap">Overlap</a> <span class="fn">sα</span> <span class="fn">e</span></span></span><div class="inductive_ctor_doc"><p>The expression <code>e</code> (the sum of monomials) is equal to <code>0</code>.</p></div></li><li class="constructor" id="Mathlib.Tactic.Ring.Overlap.nonzero">nonzero<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span>)</span> <span class="fn">e</span></span> → <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap">Overlap</a> <span class="fn">sα</span> <span class="fn">e</span></span></span><div class="inductive_ctor_doc"><p>The expression <code>e</code> (the sum of monomials) is equal to another monomial
(with nonzero leading coefficient).</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Ring.Overlap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_overlap_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L316-L317">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_overlap_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_overlap_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">pq_pf</span> : <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">e</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">x</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">e</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">e</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_overlap_pf_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L319-L321">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_overlap_pf_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_overlap_pf_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat">Meta.NormNum.IsNat</a> (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b</span>) <span class="fn">0</span></span> → <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat">Meta.NormNum.IsNat</a> (<span class="fn">x</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">e</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">x</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">e</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span>) <span class="fn">0</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalAddOverlap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L328-L353">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAddOverlap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalAddOverlap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">vb</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Control/Option.html#OptionT">OptionT</a> <a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap">Overlap</a> <span class="fn">sα</span> <span class="fn">q(<span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">«$b»</span>)</span>)</span></span></div></div><p>Given monomials <code>va, vb</code>, attempts to add them together to get another monomial.
If the monomials are not compatible, returns <code>none</code>.
For example, <code>xy + 2xy = 3xy</code> is a <code>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap.nonzero">nonzero</a></code> overlap, while <code>xy + xz</code> returns <code>none</code>
and <code>xy + -xy = 0</code> is a <code>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.zero">zero</a></code> overlap.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAddOverlap">Mathlib.Tactic.Ring.evalAddOverlap</a> <span class="fn">sα</span> <span class="fn">va</span> <span class="fn">vb</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">do
  <span class="fn"><a href="../../.././Init/Prelude.html#liftM">liftM</a> <span class="fn">(<a href="../../.././Lean/CoreM.html#Lean.Core.checkSystem">Lean.checkSystem</a> <span class="fn"><span class="fn">`Mathlib.Tactic.Ring.evalAddOverlap</span>.<a href="../../.././Init/Meta.html#Lean.Name.toString">toString</a></span>)</span></span>
  <a href="../../.././Init/Control/Option.html#OptionT.fail">OptionT.fail</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalAddOverlap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_pf_zero_add"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L355-L355">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_zero_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_zero_add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_pf_add_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L357-L357">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_add_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_pf_add_overlap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L359-L361">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_overlap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_add_overlap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₁ </span><span class="fn">a₂ </span><span class="fn">b₁ </span><span class="fn">b₂ </span><span class="fn">c₁ </span><span class="fn">c₂</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₁</span> → <span class="fn"><span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₂</span> → <span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> (<span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">c₂</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_pf_add_overlap_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L363-L365">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_overlap_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_add_overlap_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₁ </span><span class="fn">a₂ </span><span class="fn">b₁ </span><span class="fn">b₂ </span><span class="fn">c</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat">Meta.NormNum.IsNat</a> (<span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₁</span>) <span class="fn">0</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₄</span> : <span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> (<span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_pf_add_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L367-L367">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_lt"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_add_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₂ </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a₁</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → <span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_pf_add_gt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L369-L370">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_gt"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pf_add_gt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b₂ </span><span class="fn">c</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">b₁</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> (<span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalAdd"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L372-L400">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAdd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalAdd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">vb</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">«$b»</span>)</span>)</span></span></div></div><p>Adds two polynomials <code>va, vb</code> together to get a normalized result polynomial.</p><ul>
<li><code>0 + b = b</code></li>
<li><code>a + 0 = a</code></li>
<li><code>a * x + a * y = a * (x + y)</code> (for <code>x</code>, <code>y</code> coefficients; uses <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAddOverlap">evalAddOverlap</a></code>)</li>
<li><code>(a₁ + a₂) + (b₁ + b₂) = a₁ + (a₂ + (b₁ + b₂))</code> (if <code>a₁.lt b₁</code>)</li>
<li><code>(a₁ + a₂) + (b₁ + b₂) = b₁ + ((a₁ + a₂) + b₂)</code> (if not <code>a₁.lt b₁</code>)</li>
</ul></div></div><div class="decl" id="Mathlib.Tactic.Ring.one_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L402-L402">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.one_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">one_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.mul_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L404-L404">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_one"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.mul_pf_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L406-L408">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pf_left"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_pf_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₃ </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a₁</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a₂</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a₃</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → <span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a₃</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.mul_pf_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L410-L412">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pf_right"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_pf_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b₃ </span><span class="fn">c</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">b₁</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b₂</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b₃</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> (<span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b₂</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b₃</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b₂</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.mul_pp_pf_overlap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L414-L416">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pp_pf_overlap"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_pp_pf_overlap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₂ </span><span class="fn">b₂ </span><span class="fn">c</span> : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ea </span><span class="fn">eb </span><span class="fn">e</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">ea</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">eb</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span> → <span class="fn"><span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b₂</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → <span class="fn">x</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">ea</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> (<span class="fn">x</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">eb</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b₂</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">e</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalMulProd"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L418-L459">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMulProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalMulProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">vb</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">«$b»</span>)</span>)</span></span></div></div><p>Multiplies two monomials <code>va, vb</code> together to get a normalized result monomial.</p><ul>
<li><code>x * y = (x * y)</code> (for <code>x</code>, <code>y</code> coefficients)</li>
<li><code>x * (b₁ * b₂) = b₁ * (b₂ * x)</code> (for <code>x</code> coefficient)</li>
<li><code>(a₁ * a₂) * y = a₁ * (a₂ * y)</code> (for <code>y</code> coefficient)</li>
<li><code>(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)</code>
(if <code>ea</code> and <code>eb</code> are identical except coefficient)</li>
<li><code>(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))</code> (if <code>a₁.lt b₁</code>)</li>
<li><code>(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)</code> (if not <code>a₁.lt b₁</code>)</li>
</ul></div></div><div class="decl" id="Mathlib.Tactic.Ring.mul_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L461-L461">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">0</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.mul_add"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L463-L465">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b₁ </span><span class="fn">b₂ </span><span class="fn">c₁ </span><span class="fn">c₂ </span><span class="fn">d</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₁</span> → <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b₂</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₂</span> → <span class="fn"><span class="fn">c₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">c₂</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> (<span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalMul₁"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L467-L480">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMul₁"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalMul₁</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">vb</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">«$b»</span>)</span>)</span></span></div></div><p>Multiplies a monomial <code>va</code> to a polynomial <code>vb</code> to get a normalized result polynomial.</p><ul>
<li><code>a * 0 = 0</code></li>
<li><code>a * (b₁ + b₂) = (a * b₁) + (a * b₂)</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMul₁">Mathlib.Tactic.Ring.evalMul₁</a> <span class="fn">sα</span> <span class="fn">va</span> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.zero">Mathlib.Tactic.Ring.ExSum.zero</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk">{</a> <span class="fn">expr</span> := <span class="fn">q(<span class="fn">0</span>)</span>, <span class="fn">val</span> := <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.zero">Mathlib.Tactic.Ring.ExSum.zero</a>, <span class="fn">proof</span> := <span class="fn">q(<span class="fn">⋯</span>)</span> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk">}</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalMul₁" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.zero_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L482-L482">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.zero_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">zero_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L484-L485">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₁ </span><span class="fn">a₂ </span><span class="fn">b </span><span class="fn">c₁ </span><span class="fn">c₂ </span><span class="fn">d</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₁</span> → <span class="fn"><span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₂</span> → <span class="fn"><span class="fn">c₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">c₂</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span> → (<span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span>) <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalMul"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L487-L500">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalMul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">vb</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">«$b»</span>)</span>)</span></span></div></div><p>Multiplies two polynomials <code>va, vb</code> together to get a normalized result polynomial.</p><ul>
<li><code>0 * b = 0</code></li>
<li><code>(a₁ + a₂) * b = (a₁ * b) + (a₂ * b)</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMul">Mathlib.Tactic.Ring.evalMul</a> <span class="fn">sα</span> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.zero">Mathlib.Tactic.Ring.ExSum.zero</a> <span class="fn">vb</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk">{</a> <span class="fn">expr</span> := <span class="fn">q(<span class="fn">0</span>)</span>, <span class="fn">val</span> := <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.zero">Mathlib.Tactic.Ring.ExSum.zero</a>, <span class="fn">proof</span> := <span class="fn">q(<span class="fn">⋯</span>)</span> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk">}</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalMul" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.natCast_nat"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L502-L502">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_nat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">natCast_nat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">↑<span class="fn"><span class="fn">n</span>.<a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">rawCast</a></span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">n</span>.<a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">rawCast</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.natCast_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L504-L506">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">natCast_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b₁ </span><span class="fn">b₃</span> : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₁ </span><span class="fn">a₃</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a₂</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑<span class="fn">a₁</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₁</span> → <span class="fn"><span class="fn">↑<span class="fn">a₃</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₃</span> → <span class="fn">↑(<span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a₃</span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b₃</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.natCast_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L508-L508">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">natCast_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">↑<span class="fn">0</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.natCast_add"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L510-L512">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">natCast_add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b₁ </span><span class="fn">b₂</span> : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₁ </span><span class="fn">a₂</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑<span class="fn">a₁</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₁</span> → <span class="fn"><span class="fn">↑<span class="fn">a₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₂</span> → <span class="fn">↑(<span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExBase.evalNatCast"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L516-L528">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.evalNatCast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">evalNatCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">sℕ</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">↑<span class="fn">«$a»</span></span>)</span>)</span></span></div></div><p>Applies <code><a href="../../.././Init/Data/Cast.html#Nat.cast">Nat.cast</a></code> to a nat polynomial to produce a polynomial in <code>α</code>.</p><ul>
<li>An atom <code>e</code> causes <code>↑e</code> to be allocated as a new atom.</li>
<li>A sum delegates to <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalNatCast">ExSum.evalNatCast</a></code>.</li>
</ul></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.evalNatCast"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L530-L543">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalNatCast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">evalNatCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">sℕ</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">↑<span class="fn">«$a»</span></span>)</span>)</span></span></div></div><p>Applies <code><a href="../../.././Init/Data/Cast.html#Nat.cast">Nat.cast</a></code> to a nat monomial to produce a monomial in <code>α</code>.</p><ul>
<li><code>↑c = c</code> if <code>c</code> is a numeric literal</li>
<li><code>↑(a ^ n * b) = ↑a ^ n * ↑b</code></li>
</ul></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExSum.evalNatCast"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L545-L556">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalNatCast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">evalNatCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">sℕ</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">↑<span class="fn">«$a»</span></span>)</span>)</span></span></div></div><p>Applies <code><a href="../../.././Init/Data/Cast.html#Nat.cast">Nat.cast</a></code> to a nat polynomial to produce a polynomial in <code>α</code>.</p><ul>
<li><code>↑0 = 0</code></li>
<li><code>↑(a + b) = ↑a + ↑b</code></li>
</ul></div></div><div class="decl" id="Mathlib.Tactic.Ring.smul_nat"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L560-L560">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_nat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">smul_nat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.smul_eq_cast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L562-L563">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_eq_cast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">smul_eq_cast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a' </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑<span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span> → <span class="fn"><span class="fn">a'</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalNSMul"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L565-L581">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNSMul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalNSMul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">sℕ</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">vb</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">«$b»</span>)</span>)</span></span></div></div><p>Constructs the scalar multiplication <code>n • a</code>, where both <code>n : ℕ</code> and <code>a : α</code> are normalized
polynomial expressions.</p><ul>
<li><code>a • b = a * b</code> if <code>α = ℕ</code></li>
<li><code>a • b = ↑a * b</code> otherwise</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalNSMul" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.neg_one_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L583-L584">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_one_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">neg_one_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/Int/Basic.html#Int.negOfNat">Int.negOfNat</a> <span class="fn">1</span>)</span>.<a href="../../.././Mathlib/Tactic/NormNum/Result.html#Int.rawCast">rawCast</a></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> → <a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.neg_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L586-L587">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">neg_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a₁</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a₂</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₃ </span><span class="fn">b</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">a₃</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> → <a href="../../.././Init/Prelude.html#Neg.neg">-</a>(<span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a₃</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalNegProd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L589-L610">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNegProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalNegProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">rα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span>)</span> <span class="fn">q(<a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">«$a»</span>)</span>)</span></span></div></div><p>Negates a monomial <code>va</code> to get another monomial.</p><ul>
<li><code>-c = (-c)</code> (for <code>c</code> coefficient)</li>
<li><code>-(a₁ * a₂) = a₁ * -a₂</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalNegProd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.neg_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L612-L612">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">neg_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">-<span class="fn">0</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.neg_add"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L614-L616">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">neg_add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₁ </span><span class="fn">a₂ </span><span class="fn">b₁ </span><span class="fn">b₂</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₁</span> → <span class="fn"><a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₂</span> → <a href="../../.././Init/Prelude.html#Neg.neg">-</a>(<span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalNeg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L618-L630">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNeg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalNeg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">rα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">«$a»</span>)</span>)</span></span></div></div><p>Negates a polynomial <code>va</code> to get another polynomial.</p><ul>
<li><code>-0 = 0</code> (for <code>c</code> coefficient)</li>
<li><code>-(a₁ + a₂) = -a₁ + -a₂</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNeg">Mathlib.Tactic.Ring.evalNeg</a> <span class="fn">sα</span> <span class="fn">rα</span> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.zero">Mathlib.Tactic.Ring.ExSum.zero</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk">{</a> <span class="fn">expr</span> := <span class="fn">q(<span class="fn">0</span>)</span>, <span class="fn">val</span> := <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.zero">Mathlib.Tactic.Ring.ExSum.zero</a>, <span class="fn">proof</span> := <span class="fn">q(<span class="fn">⋯</span>)</span> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk">}</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalNeg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.sub_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L632-L633">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sub_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">sub_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c </span><span class="fn">d</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">c</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalSub"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L635-L644">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalSub"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalSub</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">rα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">vb</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">«$b»</span>)</span>)</span></span></div></div><p>Subtracts two polynomials <code>va, vb</code> to get a normalized result polynomial.</p><ul>
<li><code>a - b = a + -b</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalSub" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.pow_prod_atom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L646-L646">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_prod_atom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_prod_atom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span>) <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalPowProdAtom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L648-L657">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowProdAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPowProdAtom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">vb</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">sℕ</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$b»</span>)</span></span></div></div><p>The fallback case for exponentiating polynomials is to use <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.toProd">ExBase.toProd</a></code> to just build an
exponent expression. (This has a slightly different normalization than <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowAtom">evalPowAtom</a></code> because
the input types are different.)</p><ul>
<li><code>x ^ e = (x + 0) ^ e * 1</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowProdAtom">Mathlib.Tactic.Ring.evalPowProdAtom</a> <span class="fn">sα</span> <span class="fn">va</span> <span class="fn">vb</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk">{</a> <span class="fn">expr</span> := <span class="fn">q((<span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span>) <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$b»</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span>)</span>, <span class="fn">val</span> := <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.sum">Mathlib.Tactic.Ring.ExBase.sum</a> <span class="fn"><span class="fn">va</span>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.toSum">toSum</a></span>)</span>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.toProd">toProd</a></span> <span class="fn">vb</span></span>,
    <span class="fn">proof</span> := <span class="fn">q(<span class="fn">⋯</span>)</span> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk">}</a></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalPowProdAtom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.pow_atom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L659-L659">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_atom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_atom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalPowAtom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L661-L669">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPowAtom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">vb</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">sℕ</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$b»</span>)</span></span></div></div><p>The fallback case for exponentiating polynomials is to use <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.toProd">ExBase.toProd</a></code> to just build an
exponent expression.</p><ul>
<li><code>x ^ e = x ^ e * 1 + 0</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowAtom">Mathlib.Tactic.Ring.evalPowAtom</a> <span class="fn">sα</span> <span class="fn">va</span> <span class="fn">vb</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk">{</a> <span class="fn">expr</span> := <span class="fn">q(<span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$b»</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span>)</span>, <span class="fn">val</span> := <span class="fn"><span class="fn">(<span class="fn"><span class="fn">va</span>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.toProd">toProd</a></span> <span class="fn">vb</span>)</span>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.toSum">toSum</a></span>, <span class="fn">proof</span> := <span class="fn">q(<span class="fn">⋯</span>)</span> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk">}</a></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalPowAtom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.const_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L671-L671">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.const_pos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">const_pos</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Nat.ble">Nat.ble</a> <span class="fn">1</span> <span class="fn">n</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">n</span>.<a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">rawCast</a></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.mul_exp_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L673-L674">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_exp_pos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_exp_pos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₁ </span><span class="fn">a₂</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">a₁</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">a₂</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">n</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a₂</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_pos_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L676-L677">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pos_left"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pos_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₁</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a₂</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">a₁</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_pos_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L679-L680">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pos_right"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_pos_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₂</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a₁</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">a₂</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExBase.evalPos"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L684-L692">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.evalPos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExBase</span>.<span class="name">evalPos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">sℕ</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">Q(<span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">«$a»</span>)</span></span></div></div><p>Attempts to prove that a polynomial expression in <code>ℕ</code> is positive.</p><ul>
<li>Atoms are not (necessarily) positive</li>
<li>Sums defer to <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalPos">ExSum.evalPos</a></code></li>
</ul></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.evalPos"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L694-L710">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalPos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">evalPos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">sℕ</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">Q(<span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">«$a»</span>)</span></span></div></div><p>Attempts to prove that a monomial expression in <code>ℕ</code> is positive.</p><ul>
<li><code>0 &lt; c</code> (where <code>c</code> is a numeral) is true by the normalization invariant (<code>c</code> is not zero)</li>
<li><code>0 &lt; x ^ e * b</code> if <code>0 &lt; x</code> and <code>0 &lt; b</code></li>
</ul></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExSum.evalPos"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L712-L723">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalPos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">evalPos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">sℕ</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">Q(<span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">«$a»</span>)</span></span></div></div><p>Attempts to prove that a polynomial expression in <code>ℕ</code> is positive.</p><ul>
<li><code>0 &lt; 0</code> fails</li>
<li><code>0 &lt; a + b</code> if <code>0 &lt; a</code> or <code>0 &lt; b</code></li>
</ul></div></div><div class="decl" id="Mathlib.Tactic.Ring.pow_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L727-L727">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_one"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">1</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.pow_bit0"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L729-L731">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_bit0"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_bit0</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">k</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn"><a href="../../.././Init/Prelude.html#Nat.mul">Nat.mul</a> <span class="fn">2</span> <span class="fn">k</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.pow_bit1"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L733-L735">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_bit1"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_bit1</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">d</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">k</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → <span class="fn"><span class="fn">c</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#Nat.mul">Nat.mul</a> <span class="fn">2</span> <span class="fn">k</span>)</span>.<a href="../../.././Init/Prelude.html#Nat.add">add</a></span> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalPowNat"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L737-L762">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowNat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPowNat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$n»</span>)</span>)</span></span></div></div><p>The main case of exponentiation of ring expressions is when <code>va</code> is a polynomial and <code>n</code> is a
nonzero literal expression, like <code>(x + y)^5</code>. In this case we work out the polynomial completely
into a sum of monomials.</p><ul>
<li><code>x ^ 1 = x</code></li>
<li><code>x ^ (2*n) = x ^ n * x ^ n</code></li>
<li><code>x ^ (2*n+1) = x ^ n * x ^ n * x</code></li>
</ul></div></div><div class="decl" id="Mathlib.Tactic.Ring.one_pow"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L764-L764">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.one_pow"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">one_pow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.mul_pow"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L766-L768">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pow"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_pow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₂ </span><span class="fn">c₂</span> : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ea₁ </span><span class="fn">b </span><span class="fn">c₁</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">xa₁</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">ea₁</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₁</span> → <span class="fn"><span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₂</span> → (<span class="fn">xa₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">ea₁</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a₂</span>) <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">xa₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">c₁</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">c₂</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalPowProd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L770-L799">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowProd"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPowProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">vb</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">sℕ</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$b»</span>)</span>)</span></span></div></div><p>There are several special cases when exponentiating monomials:</p><ul>
<li><code>1 ^ n = 1</code></li>
<li><code>x ^ y = (x ^ y)</code> when <code>x</code> and <code>y</code> are constants</li>
<li><code>(a * b) ^ e = a ^ e * b ^ e</code></li>
</ul><p>In all other cases we use <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowProdAtom">evalPowProdAtom</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalPowProd" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExtractCoeff"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L801-L813">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExtractCoeff</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>The result of <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.extractCoeff">extractCoeff</a></code> is a numeral and a proof that the original expression
factors by this numeral.</p><ul class="structure_fields" id="Mathlib.Tactic.Ring.ExtractCoeff.mk"><li id="Mathlib.Tactic.Ring.ExtractCoeff.k" class="structure_field"><div class="structure_field_info">k : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></div><div class="structure_field_doc"><p>A raw natural number literal.</p></div></li><li id="Mathlib.Tactic.Ring.ExtractCoeff.e'" class="structure_field"><div class="structure_field_info">e' : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></div><div class="structure_field_doc"><p>The result of extracting the coefficient is a monic monomial.</p></div></li><li id="Mathlib.Tactic.Ring.ExtractCoeff.ve'" class="structure_field"><div class="structure_field_info">ve' : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">sℕ</a> <span class="fn"><span class="fn">self</span>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.e'">e'</a></span></span></div><div class="structure_field_doc"><p><code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.e'">e'</a></code> is a monomial.</p></div></li><li id="Mathlib.Tactic.Ring.ExtractCoeff.p" class="structure_field"><div class="structure_field_info">p : <span class="fn">Q(<span class="fn">«$e»</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">unknown_1</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">unknown_2</span>)</span></div><div class="structure_field_doc"><p>The proof that <code>e</code> splits into the coefficient <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.k">k</a></code> and the monic monomial <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.e'">e'</a></code>.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Ring.ExtractCoeff" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.coeff_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L815-L815">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.coeff_one"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">coeff_one</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">k</span>.<a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">rawCast</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.coeff_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L817-L819">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.coeff_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">coeff_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₃ </span><span class="fn">c₂ </span><span class="fn">k</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a₁ </span><span class="fn">a₂</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a₃</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₂</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">k</span> → <span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a₃</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">c₂</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.extractCoeff"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L821-L834">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.extractCoeff"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">extractCoeff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">sℕ</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff">ExtractCoeff</a> <span class="fn">a</span></span></div></div><p>Given a monomial expression <code>va</code>, splits off the leading coefficient <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.k">k</a></code> and the remainder
<code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.e'">e'</a></code>, stored in the <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff">ExtractCoeff</a></code> structure.</p><ul>
<li><code>c = 1 * c</code> (if <code>c</code> is a constant)</li>
<li><code>a * b = (a * b') * <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.k">k</a></code> if <code>b = b' * <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.k">k</a></code></li>
</ul><details id="instances-for-list-Mathlib.Tactic.Ring.extractCoeff" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.pow_one_cast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L836-L836">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_one_cast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_one_cast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.zero_pow"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L838-L838">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.zero_pow"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">zero_pow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">0</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">b</span> → <span class="fn">0</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.single_pow"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L840-L841">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.single_pow"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">single_pow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">c</span> : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span>) <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.pow_nat"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L843-L845">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_nat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_nat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b </span><span class="fn">c </span><span class="fn">k</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">d </span><span class="fn">e</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">k</span> → <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">c</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span> → <span class="fn"><span class="fn">d</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">k</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">e</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalPow₁"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L847-L875">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPow₁"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPow₁</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">vb</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">sℕ</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$b»</span>)</span>)</span></span></div></div><p>Exponentiates a polynomial <code>va</code> by a monomial <code>vb</code>, including several special cases.</p><ul>
<li><code>a ^ 1 = a</code></li>
<li><code>0 ^ e = 0</code> if <code>0 &lt; e</code></li>
<li><code>(a + 0) ^ b = a ^ b</code> computed using <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowProd">evalPowProd</a></code></li>
<li><code>a ^ b = (a ^ b') ^ <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.k">k</a></code> if <code>b = b' * <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.k">k</a></code> and <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.k">k</a> &gt; 1</code></li>
</ul><p>Otherwise <code>a ^ b</code> is just encoded as <code>a ^ b * 1 + 0</code> using <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowAtom">evalPowAtom</a></code>.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.pow_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L877-L877">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">0</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.pow_add"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L879-L881">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">c₁ </span><span class="fn">c₂</span> : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b₁ </span><span class="fn">b₂</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">d</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₁</span> → <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b₂</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c₂</span> → <span class="fn"><span class="fn">c₁</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">c₂</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> (<span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalPow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L883-L896">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPow"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalPow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">Q(<a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">vb</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">sℕ</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">«$b»</span>)</span>)</span></span></div></div><p>Exponentiates two polynomials <code>va, vb</code>.</p><ul>
<li><code>a ^ 0 = 1</code></li>
<li><code>a ^ (b₁ + b₂) = a ^ b₁ * a ^ b₂</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPow">Mathlib.Tactic.Ring.evalPow</a> <span class="fn">sα</span> <span class="fn">va</span> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.zero">Mathlib.Tactic.Ring.ExSum.zero</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk">{</a> <span class="fn">expr</span> := <span class="fn">q(<span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span>)</span>, <span class="fn">val</span> := <span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNat">Mathlib.Tactic.Ring.ExProd.mkNat</a> <span class="fn">sα</span> <span class="fn">1</span>)</span>.<a href="../../.././Init/Core.html#Sigma.snd">snd</a></span>.<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.toSum">toSum</a></span>, <span class="fn">proof</span> := <span class="fn">q(<span class="fn">⋯</span>)</span> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk">}</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalPow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.Cache"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L898-L905">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">Cache</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><p>This cache contains data required by the <code>ring</code> tactic during execution.</p><ul class="structure_fields" id="Mathlib.Tactic.Ring.Cache.mk"><li id="Mathlib.Tactic.Ring.Cache.rα" class="structure_field"><div class="structure_field_info">rα : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">«$α»</span></span>)</span></span></div><div class="structure_field_doc"><p>A ring instance on <code>α</code>, if available.</p></div></li><li id="Mathlib.Tactic.Ring.Cache.dα" class="structure_field"><div class="structure_field_info">dα : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">«$α»</span></span>)</span></span></div><div class="structure_field_doc"><p>A division ring instance on <code>α</code>, if available.</p></div></li><li id="Mathlib.Tactic.Ring.Cache.czα" class="structure_field"><div class="structure_field_info">czα : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/CharZero/Defs.html#CharZero">CharZero</a> <span class="fn">«$α»</span></span>)</span></span></div><div class="structure_field_doc"><p>A characteristic zero ring instance on <code>α</code>, if available.</p></div></li></ul><details id="instances-for-list-Mathlib.Tactic.Ring.Cache" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.mkCache"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L907-L912">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mkCache"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mkCache</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache">Cache</a> <span class="fn">sα</span>)</span></span></div></div><p>Create a new cache for <code>α</code> by doing the necessary instance searches.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.mkCache" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.cast_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L914-L915">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_pos"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">cast_pos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat">Meta.NormNum.IsNat</a> <span class="fn">a</span> <span class="fn">n</span></span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">n</span>.<a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">rawCast</a></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.cast_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L917-L918">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">cast_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat">Meta.NormNum.IsNat</a> <span class="fn">a</span> <span class="fn">0</span></span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.cast_neg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L920-L922">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_neg"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">cast_neg</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt">Meta.NormNum.IsInt</a> <span class="fn">a</span> <span class="fn">(<a href="../../.././Init/Data/Int/Basic.html#Int.negOfNat">Int.negOfNat</a> <span class="fn">n</span>)</span></span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../.././Init/Data/Int/Basic.html#Int.negOfNat">Int.negOfNat</a> <span class="fn">n</span>)</span>.<a href="../../.././Mathlib/Tactic/NormNum/Result.html#Int.rawCast">rawCast</a></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.cast_nnrat"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L924-L926">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_nnrat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">cast_nnrat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n </span><span class="fn">d</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionSemiring">DivisionSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat">Meta.NormNum.IsNNRat</a> <span class="fn">a</span> <span class="fn">n</span> <span class="fn">d</span></span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#NNRat.rawCast">NNRat.rawCast</a> <span class="fn">n</span> <span class="fn">d</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.cast_rat"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L928-L930">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_rat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">cast_rat</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Data/Int/Basic.html#Int">ℤ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">d</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat">Meta.NormNum.IsRat</a> <span class="fn">a</span> <span class="fn">n</span> <span class="fn">d</span></span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Rat.rawCast">Rat.rawCast</a> <span class="fn">n</span> <span class="fn">d</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalCast"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L932-L956">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalCast"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result">Meta.NormNum.Result</a> <span class="fn">e</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">e</span>)</span></span></span></div></div><p>Converts a proof by <code><a href="../../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> that <code>e</code> is a numeral, into a normalization as a monomial:</p><ul>
<li><code>e = 0</code> if <code><a href="../../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> returns <code>IsNat e 0</code></li>
<li><code>e = <a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> n + 0</code> if <code><a href="../../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> returns <code>IsNat e n</code></li>
<li><code>e = <a href="../../.././Mathlib/Tactic/NormNum/Result.html#Int.rawCast">Int.rawCast</a> n + 0</code> if <code><a href="../../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> returns <code>IsInt e n</code></li>
<li><code>e = <a href="../../.././Mathlib/Tactic/NormNum/Result.html#NNRat.rawCast">NNRat.rawCast</a> n d + 0</code> if <code><a href="../../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> returns <code>IsNNRat e n d</code></li>
<li><code>e = <a href="../../.././Mathlib/Tactic/NormNum/Result.html#Rat.rawCast">Rat.rawCast</a> n d + 0</code> if <code><a href="../../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code> returns <code>IsRat e n d</code></li>
</ul><details id="instances-for-list-Mathlib.Tactic.Ring.evalCast" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.toProd_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L958-L959">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.toProd_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">toProd_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a'</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.atom_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L960-L960">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.atom_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">atom_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">R</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.atom_pf'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L961-L962">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.atom_pf'"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">atom_pf'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a'</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalAtom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L964-L976">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalAtom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">e</span>)</span></span></div></div><p>Evaluates an atom, an expression where <code>ring</code> can find no additional structure.</p><ul>
<li><code>a = a ^ 1 * 1 + 0</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalAtom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.inv_mul"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L978-L981">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_mul"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">inv_mul</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₁</span> : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₂</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₃ </span><span class="fn">b₁ </span><span class="fn">b₃ </span><span class="fn">c</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a₁</span><a href="../../.././Init/Prelude.html#Inv.inv">⁻¹</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₁</span> → <span class="fn"><span class="fn">a₃</span><a href="../../.././Init/Prelude.html#Inv.inv">⁻¹</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₃</span> → <span class="fn"><span class="fn">b₃</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> (<span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn"><a href="../../.././Mathlib/Tactic/NormNum/Result.html#Nat.rawCast">Nat.rawCast</a> <span class="fn">1</span></span>) <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → (<span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">a₂</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">a₃</span>)<a href="../../.././Init/Prelude.html#Inv.inv">⁻¹</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.inv_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L983-L983">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_zero"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">inv_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">0</span><a href="../../.././Init/Prelude.html#Inv.inv">⁻¹</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.inv_single"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L985-L986">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_single"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">inv_single</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span><a href="../../.././Init/Prelude.html#Inv.inv">⁻¹</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> → (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span>)<a href="../../.././Init/Prelude.html#Inv.inv">⁻¹</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.inv_add"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L987-L989">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_add"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">inv_add</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b₁ </span><span class="fn">b₂</span> : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a₁ </span><span class="fn">a₂</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">↑<span class="fn">a₁</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₁</span> → <span class="fn"><span class="fn">↑<span class="fn">a₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₂</span> → <span class="fn">↑(<span class="fn">a₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">a₂</span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b₁</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b₂</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalInvAtom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L995-L998">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalInvAtom"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalInvAtom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">dα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase">ExBase</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">«$a»</span><a href="../../.././Init/Prelude.html#Inv.inv">⁻¹</a>)</span>)</span></span></div></div><p>Applies <code>⁻¹</code> to a polynomial to get an atom.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalInvAtom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExProd.evalInv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1000-L1025">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalInv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExProd</span>.<span class="name">evalInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">dα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">czα</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/CharZero/Defs.html#CharZero">CharZero</a> <span class="fn">«$α»</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd">ExProd</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">«$a»</span><a href="../../.././Init/Prelude.html#Inv.inv">⁻¹</a>)</span>)</span></span></div></div><p>Inverts a polynomial <code>va</code> to get a normalized result polynomial.</p><ul>
<li><code>c⁻¹ = (c⁻¹)</code> if <code>c</code> is a constant</li>
<li><code>(a ^ b * c)⁻¹ = a⁻¹ ^ b * c⁻¹</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.ExProd.evalInv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ExSum.evalInv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1027-L1041">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalInv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ExSum</span>.<span class="name">evalInv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">dα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">czα</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/CharZero/Defs.html#CharZero">CharZero</a> <span class="fn">«$α»</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">«$a»</span><a href="../../.././Init/Prelude.html#Inv.inv">⁻¹</a>)</span>)</span></span></div></div><p>Inverts a polynomial <code>va</code> to get a normalized result polynomial.</p><ul>
<li><code>0⁻¹ = 0</code></li>
<li><code>a⁻¹ = (a⁻¹)</code> if <code>a</code> is a nontrivial sum</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalInv">Mathlib.Tactic.Ring.ExSum.evalInv</a> <span class="fn">sα</span> <span class="fn">dα</span> <span class="fn">czα</span> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.zero">Mathlib.Tactic.Ring.ExSum.zero</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk">{</a> <span class="fn">expr</span> := <span class="fn">q(<span class="fn">0</span>)</span>, <span class="fn">val</span> := <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.zero">Mathlib.Tactic.Ring.ExSum.zero</a>, <span class="fn">proof</span> := <span class="fn">q(<span class="fn">⋯</span>)</span> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk">}</a></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.ExSum.evalInv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.div_pf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1045-L1046">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.div_pf"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">div_pf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c </span><span class="fn">d</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span><a href="../../.././Init/Prelude.html#Inv.inv">⁻¹</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">c</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.evalDiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1048-L1056">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalDiv"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">evalDiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">rα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">czα</span> : <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/CharZero/Defs.html#CharZero">CharZero</a> <span class="fn">«$α»</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">va</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">vb</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">q(<span class="fn">«$a»</span> <a href="../../.././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn">«$b»</span>)</span>)</span></span></div></div><p>Divides two polynomials <code>va, vb</code> to get a normalized result polynomial.</p><ul>
<li><code>a / b = a * b⁻¹</code></li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.evalDiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.add_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1058-L1059">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">add_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a' </span><span class="fn">b </span><span class="fn">b' </span><span class="fn">c</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span> → <span class="fn"><span class="fn">a'</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b'</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.mul_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1061-L1062">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">mul_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a' </span><span class="fn">b </span><span class="fn">b' </span><span class="fn">c</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span> → <span class="fn"><span class="fn">a'</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b'</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HMul.hMul">*</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.nsmul_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1064-L1066">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.nsmul_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">nsmul_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b </span><span class="fn">b' </span><span class="fn">c</span> : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a'</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span> → <span class="fn"><span class="fn">a'</span> <a href="../../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">b'</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HSMul.hSMul">•</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.pow_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1068-L1069">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">pow_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a' </span><span class="fn">c</span> : <span class="fn">R</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b </span><span class="fn">b'</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span> → <span class="fn"><span class="fn">a'</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b'</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HPow.hPow">^</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.neg_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1071-L1072">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">neg_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a' </span><span class="fn">b</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span> → <span class="fn"><a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">a'</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> → <a href="../../.././Init/Prelude.html#Neg.neg">-</a><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.sub_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1074-L1075">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sub_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">sub_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#Ring">Ring</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a' </span><span class="fn">b </span><span class="fn">b' </span><span class="fn">c</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span> → <span class="fn"><span class="fn">a'</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">b'</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.inv_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1077-L1078">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">inv_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a' </span><span class="fn">b</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span> → <span class="fn"><span class="fn">a'</span><a href="../../.././Init/Prelude.html#Inv.inv">⁻¹</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> → <span class="fn">a</span><a href="../../.././Init/Prelude.html#Inv.inv">⁻¹</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.div_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1080-L1081">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.div_congr"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">div_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">R</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Algebra/Field/Defs.html#DivisionRing">DivisionRing</a> <span class="fn">R</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a' </span><span class="fn">b </span><span class="fn">b' </span><span class="fn">c</span> : <span class="fn">R</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span> → <span class="fn"><span class="fn">a'</span> <a href="../../.././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn">b'</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#HDiv.hDiv">/</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.Cache.nat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1083-L1084">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.nat"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">Cache</span>.<span class="name">nat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache">Cache</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ">sℕ</a></span></div></div><p>A precomputed <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache">Cache</a></code> for <code>ℕ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.nat">Mathlib.Tactic.Ring.Cache.nat</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.mk">{</a> <span class="fn">rα</span> := <a href="../../.././Init/Prelude.html#Option.none">none</a>, <span class="fn">dα</span> := <a href="../../.././Init/Prelude.html#Option.none">none</a>, <span class="fn">czα</span> := <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">q(<span class="fn">⋯</span>)</span></span> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.mk">}</a></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.Cache.nat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.isAtomOrDerivable"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1086-L1113">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.isAtomOrDerivable"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">isAtomOrDerivable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache">Cache</a> <span class="fn">sα</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">e</span>)</span>)</span>)</span></span></div></div><p>Checks whether <code>e</code> would be processed by <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.eval">eval</a></code> as a ring expression,
or otherwise if it is an atom or something simplifiable via <code><a href="../../.././Mathlib/Tactic/NormNum/Core.html#norm_num">norm_num</a></code>.</p><p>We use this in <code>ring_nf</code> to avoid rewriting atoms unnecessarily.</p><p>Returns:</p><ul>
<li><code>none</code> if <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.eval">eval</a></code> would process <code>e</code> as an algebraic ring expression</li>
<li><code>some none</code> if <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.eval">eval</a></code> would treat <code>e</code> as an atom.</li>
<li><code>some (some r)</code> if <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.eval">eval</a></code> would not process <code>e</code> as an algebraic ring expression,
but <code>NormNum.derive</code> can nevertheless simplify <code>e</code>, with result <code>r</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.isAtomOrDerivable" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.eval"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1115-L1180">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.eval"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">u</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> u)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">c</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache">Cache</a> <span class="fn">sα</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result">Result</a> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum">ExSum</a> <span class="fn">sα</span>)</span> <span class="fn">e</span>)</span></span></div></div><p>Evaluates expression <code>e</code> of type <code>α</code> into a normalized representation as a polynomial.
This is the main driver of <code>ring</code>, which calls out to <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAdd">evalAdd</a></code>, <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMul">evalMul</a></code> etc.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.CSLift"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1184-L1191">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">CSLift</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">β</span> : <span class="fn"><a href="../../.././Init/Prelude.html#outParam">outParam</a> <a href="../../.././foundational_types.html">(Type</a> u)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> u</div></div><p><code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift">CSLift</a> α β</code> is a typeclass used by <code>ring</code> for lifting operations from <code>α</code>
(which is not a commutative semiring) into a commutative semiring <code>β</code> by using an injective map
<code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift">lift</a> : α → β</code>.</p><ul class="structure_fields" id="Mathlib.Tactic.Ring.CSLift.mk"><li id="Mathlib.Tactic.Ring.CSLift.lift" class="structure_field"><div class="structure_field_info">lift : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span></div><div class="structure_field_doc"><p><code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift">lift</a></code> is the &quot;canonical injection&quot; from <code>α</code> to <code>β</code></p></div></li><li id="Mathlib.Tactic.Ring.CSLift.inj" class="structure_field"><div class="structure_field_info">inj : <span class="fn"><a href="../../.././Mathlib/Logic/Function/Defs.html#Function.Injective">Function.Injective</a> <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift">lift</a></span></div><div class="structure_field_doc"><p><code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift">lift</a></code> is an injective function</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Mathlib.Tactic.Ring.CSLift" class="instances-list"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.CSLiftVal"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1193-L1199">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">CSLiftVal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><a href="../../.././Init/Prelude.html#outParam">outParam</a> <a href="../../.././foundational_types.html">(Type</a> u)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift">CSLift</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">b</span> : <span class="fn"><a href="../../.././Init/Prelude.html#outParam">outParam</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p><code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal">CSLiftVal</a> a b</code> means that <code>b = <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift">lift</a> a</code>. This is used by <code>ring</code> to construct an expression <code>b</code>
from the input expression <code>a</code>, and then run the usual ring algorithm on <code>b</code>.</p><ul class="structure_fields" id="Mathlib.Tactic.Ring.CSLiftVal.mk"><li id="Mathlib.Tactic.Ring.CSLiftVal.eq" class="structure_field"><div class="structure_field_info">eq : <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift">CSLift.lift</a> <span class="fn">a</span></span></div><div class="structure_field_doc"><p>The output value <code>b</code> is equal to the lift of <code>a</code>. This can be supplied by the default
instance which sets <code>b := <a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift">lift</a> a</code>, but <code>ring</code> will treat this as an atom so it is more useful
when there are other instances which distribute addition or multiplication.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-Mathlib.Tactic.Ring.CSLiftVal" class="instances-list"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.instCSLiftValLift"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1201-L1201">source</a></div><div class="attributes">@[instance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCSLiftValLift"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">instCSLiftValLift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift">CSLift</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal">CSLiftVal</a> <span class="fn">a</span> <span class="fn">(<a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift">CSLift.lift</a> <span class="fn">a</span>)</span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.of_lift"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1203-L1205">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.of_lift"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">of_lift</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α </span><span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift">CSLift</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a' </span><span class="fn">b'</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h1</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal">CSLiftVal</a> <span class="fn">a</span> <span class="fn">a'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">h2</span> : <span class="fn"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal">CSLiftVal</a> <span class="fn">b</span> <span class="fn">b'</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a'</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1209-L1209">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.of_eq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b </span><span class="fn">c</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">c</span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></div></div></div></div><div class="decl" id="Mathlib.Tactic.Ring.ringCleanupRef"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1211-L1216">source</a></div><div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ringCleanupRef"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ringCleanupRef</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/System/IO.html#IO.Ref">IO.Ref</a> <span class="fn">(<a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a> → <span class="fn"><a href="../../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span></div></div><p>This is a routine which is used to clean up the unsolved subgoal
of a failed <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ring1">ring1</a></code> application. It is overridden in <code><a href="../../.././Mathlib/Tactic/Ring/RingNF.html">Mathlib/Tactic/Ring/RingNF.lean</a></code>
to apply the <code>ring_nf</code> simp set to the goal.</p></div></div><div class="decl" id="Mathlib.Tactic.Ring.proveEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1218-L1257">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.proveEq"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">proveEq</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">g</span> : <a href="../../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <a href="../../.././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Frontend of <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ring1">ring1</a></code>: attempt to close a goal <code>g</code>, assuming it is an equation of semirings.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.proveEq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.proveEq.ringCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1247-L1257">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.proveEq.ringCore"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">proveEq</span>.<span class="name">ringCore</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <a href="../../.././Lean/Level.html#Lean.Level">Lean.Level</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <span class="fn">Q(<a href="../../.././foundational_types.html">Type</a> v)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">sα</span> : <span class="fn">Q(<span class="fn"><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a> <span class="fn">«$α»</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">e₁ </span><span class="fn">e₂</span> : <span class="fn">Q(<span class="fn">«$α»</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM">AtomM</a> <span class="fn">Q(<span class="fn">«$e₁»</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">«$e₂»</span>)</span></span></div></div><p>The core of <code><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.proveEq">proveEq</a></code> takes expressions <code>e₁ e₂ : α</code> where <code>α</code> is a <code><a href="../../.././Mathlib/Algebra/Ring/Defs.html#CommSemiring">CommSemiring</a></code>,
and returns a proof that they are equal (or fails).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.proveEq.ringCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.ring1"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1259-L1268">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ring1"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">ring1</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Tactic for solving equations of <em>commutative</em> (semi)rings,
allowing variables in the exponent.</p><ul>
<li>This version of <code>ring</code> fails if the target is not an equality.</li>
<li>The variant <code>ring1!</code> will use a more aggressive reducibility setting
to determine equality of atoms.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.ring1" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Mathlib.Tactic.Ring.tacticRing1!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/90c0e186fd333cbdddbe0e5148aa3cd2d24dcf9a/Mathlib/Tactic/Ring/Basic.lean#L1270-L1270">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.tacticRing1!"><span class="name">Mathlib</span>.<span class="name">Tactic</span>.<span class="name">Ring</span>.<span class="name">tacticRing1!</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Tactic for solving equations of <em>commutative</em> (semi)rings,
allowing variables in the exponent.</p><ul>
<li>This version of <code>ring</code> fails if the target is not an equality.</li>
<li>The variant <code>ring1!</code> will use a more aggressive reducibility setting
to determine equality of atoms.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.tacticRing1!">Mathlib.Tactic.Ring.tacticRing1!</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Mathlib.Tactic.Ring.tacticRing1!</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;ring1!&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Mathlib.Tactic.Ring.tacticRing1!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>