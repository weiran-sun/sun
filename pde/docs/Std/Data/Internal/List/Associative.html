<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../../.././style.css"></link><link rel="icon" href="../../../.././favicon.svg"></link><link rel="mask-icon" href="../../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../../.././/declarations/declaration-data.bmp" as="image"></link><title>Std.Data.Internal.List.Associative</title><script defer="true" src="../../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../../.././";</script><script>const MODULE_NAME="Std.Data.Internal.List.Associative";</script><script type="module" src="../../../.././jump-src.js"></script><script type="module" src="../../../.././search.js"></script><script type="module" src="../../../.././expand-nav.js"></script><script type="module" src="../../../.././how-about.js"></script><script type="module" src="../../../.././instances.js"></script><script type="module" src="../../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Std</span>.<span class="name">Data</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Associative</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../../.././Init/Data/BEq.html">Init.Data.BEq</a></li><li><a href="../../../.././Init/Data/List/Find.html">Init.Data.List.Find</a></li><li><a href="../../../.././Init/Data/List/MinMax.html">Init.Data.List.MinMax</a></li><li><a href="../../../.././Init/Data/List/Monadic.html">Init.Data.List.Monadic</a></li><li><a href="../../../.././Init/Data/List/Perm.html">Init.Data.List.Perm</a></li><li><a href="../../../.././Init/Data/Nat/Simproc.html">Init.Data.Nat.Simproc</a></li><li><a href="../../../.././Init/Data/Option/Attach.html">Init.Data.Option.Attach</a></li><li><a href="../../../.././Init/Data/Order/Lemmas.html">Init.Data.Order.Lemmas</a></li><li><a href="../../../.././Init/Data/Subtype/Order.html">Init.Data.Subtype.Order</a></li><li><a href="../../../.././Std/Classes/Ord/Basic.html">Std.Classes.Ord.Basic</a></li><li><a href="../../../.././Std/Data/Internal/List/Defs.html">Std.Data.Internal.List.Defs</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Std.Data.Internal.List.Associative" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.assoc_induction"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">assoc_induction</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eq_find"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_find</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.beq_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">beq_of_getEntry?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_eq_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_eq_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_some_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_iff_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getEntry?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_isSome_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_iff_forall_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_iff_forall_isSome_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_isSome_getValue?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_getValueCast?_eq_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_getValueCast?_eq_isSome_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_isSome_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_cons_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_cons_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_cons_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_true_iff_exists_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_true_iff_exists_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_contains_map_fst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_contains_map_fst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_keys_eq_length"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_keys_eq_length</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_keys_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_keys_eq_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_keys_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_keys_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_mem_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_mem_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.def"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">def</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.perm_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">perm_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.distinctKeys_of_sublist_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">distinctKeys_of_sublist_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.distinctKeys_of_sublist"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">distinctKeys_of_sublist</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.of_keys_eq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">of_keys_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_iff_exists"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_iff_exists</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_false_iff_forall_mem_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_false_iff_forall_mem_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_false_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_false_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.distinctKeys_cons_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">distinctKeys_cons_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.tail"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">tail</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_false_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_false_iff_exists_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_iff_forall_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_none</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_none</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_isSome_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getValue?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_isSome_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_getValueCast?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_getValueCast?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_getValue_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_getValue_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_none</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eq_some_getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_some_getEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_eq_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_eq_of_getEntry?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_cons_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_some_getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_getValue</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_eq_getEntry_snd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getEntry_snd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_eq_some_getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_some_getValueCast</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_eq_getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getValueCast</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eq_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eq_fallback</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_eq_getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eq_getValueCastD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_eq_some_getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_some_getValueCastD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eq_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eq_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_eq_getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eq_getValueCast!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_eq_some_getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_some_getValueCast!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_eq_getValueCastD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eq_getValueCastD_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_eq_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eq_getValue?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eq_fallback</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_eq_getValueD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getValueD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_some_getValueD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_getValueD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_eq_getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eq_getValueCastD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_eq_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_getValue?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_eq_getValue!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getValue!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_some_getValue!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_getValue!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_eq_getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_getValueCast!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_eq_getValueD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_getValueD_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_cons_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.fst_mem_keys_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">fst_mem_keys_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eq_isSome_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eq_some_iff_getKey?_eq_some_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_some_iff_getKey?_eq_some_getValue?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_some_getKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_getKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_eq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_eq_getEntry_fst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq_getEntry_fst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.forall_mem_keys_iff_forall_containsKey_getKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forall_mem_keys_iff_forall_containsKey_getKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_eq_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eq_getKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eq_fallback</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_eq_getKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq_getKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_eq_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eq_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_some_getKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_getKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_eq_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_getKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_eq_getKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq_getKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_eq_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_some_getKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_getKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_eq_getKeyD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_getKeyD_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_eq_getKey_getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_eq_getKey_getValue</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_cons_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_replaceEntry_of_beq_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_replaceEntry_of_beq_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_replaceEntry_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_replaceEntry_of_key_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_replaceEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_replaceEntry_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_replaceEntry_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_getEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_replaceEntry_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_replaceEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_replaceEntry_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_replaceEntry_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_replaceEntry_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_replaceEntry_of_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_eraseKey_of_key_beq_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_eraseKey_of_key_beq_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_eraseKey_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_eraseKey_of_key_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.sublist_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">sublist_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_eraseKey_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_eraseKey_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_le_length_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_cons_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_cons_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_cons_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_insertEntry_of_key_beq_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_insertEntry_of_key_beq_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_insertEntry_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_insertEntry_of_key_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_le_length_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertEntry_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntry_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertEntry_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertEntry_of_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_of_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertEntry_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_none</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertEntry_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntry_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertEntry_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntryIfNew_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntryIfNew_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertEntryIfNew_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntryIfNew_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_insertEntryIfNew'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertEntryIfNew'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_le_length_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertEntryIfNew_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntryIfNew_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eraseKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eraseKey_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_filterMap'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_filterMap'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_keys_iff_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_keys_iff_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.keys_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">keys_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.keys_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eraseKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eraseKey_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eraseKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eraseKey_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey_of_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_isEmpty_eraseKey_and_not_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_isEmpty_eraseKey_and_not_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_eq_false_of_isEmpty_eraseKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_of_isEmpty_eraseKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eraseKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.perm_cons_getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_cons_getEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_ext</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_ext</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_getValue?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_getValue?_ext</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_getValue?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_getValue?_ext</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_ext</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_ext</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntryIfNew_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_append"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_append</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_append"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_append</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_flatMap_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_flatMap_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_append_of_not_contains_right"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_append_of_not_contains_right</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_append"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_append</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_append_of_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_append_of_containsKey_left"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_append_of_containsKey_left</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_append_of_containsKey_left_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_append_of_containsKey_left_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_append_of_containsKey_right_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertEntry_append_of_not_contains_right"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_append_of_not_contains_right</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eraseKey_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_append_of_containsKey_right_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_iff_getValueCast?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getValueCast?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.find?_eq_some_iff_getValueCast?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_eq_some_iff_getValueCast?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.find?_eq_none_iff_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_eq_none_iff_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.pairwise_fst_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">pairwise_fst_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.map_fst_map_toProd_eq_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">map_fst_map_toProd_eq_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.find?_map_eq_none_iff_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_map_eq_none_iff_containsKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_map_toProd_iff_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_map_toProd_iff_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_iff_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getValue?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_map_toProd_iff_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_map_toProd_iff_getValue?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.find?_map_toProd_eq_some_iff_getKey?_eq_some_and_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_map_toProd_eq_some_iff_getKey?_eq_some_and_getValue?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_iff_getKey?_eq_some_and_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getKey?_eq_some_and_getValue?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_eq_some_iff_exists_beq_and_mem_toList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_iff_exists_beq_and_mem_toList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_map_toProd_iff_getKey?_eq_some_and_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_map_toProd_iff_getKey?_eq_some_and_getValue?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.pairwise_fst_eq_false_map_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">pairwise_fst_eq_false_map_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldlM_eq_foldlM_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldlM_eq_foldlM_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldl_eq_foldl_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldl_eq_foldl_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldrM_eq_foldrM_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldrM_eq_foldrM_toProd'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_toProd'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldr_eq_foldr_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldr_eq_foldr_toProd'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_toProd'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.forM_eq_forM_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forM_eq_forM_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.forIn_eq_forIn_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forIn_eq_forIn_toProd</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldlM_eq_foldlM_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldlM_eq_foldlM_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldl_eq_foldl_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldl_eq_foldl_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldrM_eq_foldrM_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldrM_eq_foldrM_keys'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_keys'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldr_eq_foldr_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.foldr_eq_foldr_keys'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_keys'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.forM_eq_forM_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forM_eq_forM_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.forIn_eq_forIn_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forIn_eq_forIn_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertList_perm_of_perm_first"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertList_perm_of_perm_first</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertList_cons_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertList_cons_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertList_of_contains_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertList_of_contains_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertList_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.perm_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_le_length_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertList_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertList_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertList</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Prod.toSigma"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Prod</span>.<span class="name">toSigma</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Prod.fst_comp_toSigma"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Prod</span>.<span class="name">fst_comp_toSigma</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertListConst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertListConst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertListConst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListConst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_le_length_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertListConst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertListConst_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListConst_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertListConst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue!_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertListConst_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueD_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertListConst_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.insertListIfNewUnit_perm_of_perm_first"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertListIfNewUnit_perm_of_perm_first</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.mapUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">mapUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_insertListIfNewUnit_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertListIfNewUnit_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListIfNewUnit_of_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListIfNewUnit_of_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListIfNewUnit_of_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListIfNewUnit_of_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_le_length_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_insertListIfNewUnit_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListIfNewUnit_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_list_unit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_list_unit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue?_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertListIfNewUnit</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_alterKey'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_alterKey'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.alterKey_cons_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_cons_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_alterKey_eq_isEmpty_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_alterKey_eq_isEmpty_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.alterKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.alterKey_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_append_of_containsKey_right_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.alterKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_alterKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.mem_alterKey_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_alterKey_of_key_ne</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_alterKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_alterKey'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_alterKey_eq_add_one"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_add_one</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_alterKey_eq_sub_one"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_sub_one</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_alterKey_eq_self'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_self'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.alterKey_cons_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_cons_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_alterKey_eq_isEmpty_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_alterKey_eq_isEmpty_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.alterKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.alterKey_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_append_of_containsKey_right_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.alterKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_alterKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.mem_alterKey_of_key_not_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">mem_alterKey_of_key_not_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_alterKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKeyD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.constAlterKey_eq_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">constAlterKey_eq_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.constAlterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">constAlterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.modifyKey_eq_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">modifyKey_eq_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.modifyKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">modifyKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.modifyKey_eq_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">modifyKey_eq_alterKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.modifyKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">modifyKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKeyD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_modifyKey_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.constModifyKey_eq_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">constModifyKey_eq_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.constModifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">constModifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.guard_eq_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">guard_eq_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Sigma.snd_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Sigma</span>.<span class="name">snd_congr</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_filterMap'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_filterMap'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_map'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_map'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_filterMap'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_filterMap'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.snd_eq_getValueCast_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">snd_eq_getValueCast_of_getEntry?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.eq_getKey_getValue_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eq_getKey_getValue_of_getEntry?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_apply_of_containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_apply_of_containsKey_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isSome_apply_of_containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_apply_of_containsKey_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_of_containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.apply_eq_true_of_containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">apply_eq_true_of_containsKey_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast!_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCastD_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filter_key</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Option.exists_eq_some_and_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">exists_eq_some_and_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_filterMap_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filterMap_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_filter_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filter_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_filterMap_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filterMap_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.containsKey_filter_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filter_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValueCast_eq_get_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eq_get_getValueCast?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_filter_key</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_filter_key</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_filter_key</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getValue_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_filterMap_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_filterMap_eq_length_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.key_getValueCast_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">key_getValueCast_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.forall_mem_iff_forall_contains_getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forall_mem_iff_forall_contains_getValueCast</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_filter_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_filter_eq_length_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.length_filter_key_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_filter_key_eq_length_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.perm_filter_self_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_filter_self_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.perm_filter_self_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_filter_self_iff_forall_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.perm_filter_key_self_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_filter_key_self_iff_forall_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.perm_filter_self_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">perm_filter_self_iff_forall_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_filterMap_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filterMap_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_filterMap_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filterMap_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_filter_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filter_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_filter_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filter_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isEmpty_filter_key_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filter_key_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey_getValue_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_getValue_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.forall_mem_iff_forall_contains_getKey_getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">forall_mem_iff_forall_contains_getKey_getValue</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_filterMap_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filterMap_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_filterMap_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filterMap_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_filterMap_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filterMap_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_filter_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filter_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_filter_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filter_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_filter_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filter_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue?_map_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_map_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue!_map_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_map_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValueD_map_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_map_of_getKey?_eq_some</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKeyD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_filterMap</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getValue_eq_get_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_eq_get_getValue?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKey!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.getKeyD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_filter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_filterMap_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_filterMap_eq_length_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_filter_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_filter_eq_length_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.length_filter_key_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_filter_key_eq_length_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_filterMap_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filterMap_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_filterMap_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filterMap_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_filter_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_filter_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_filter_key_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_key_eq_true</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isEmpty_filter_key_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_key_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.toList_map'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">toList_map'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.toList_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">toList_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.DistinctKeys.eq_of_mem_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">eq_of_mem_of_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_eq_head?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_eq_head?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minEntry?_of_isEmpty_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_of_isEmpty_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_eq_some_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_some_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_some_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_eq_none_iff_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_eq_none_iff_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_none_iff_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_none_iff_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_of_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_of_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isNone_minEntry?_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isNone_minEntry?_eq_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isNone_minKey?_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isNone_minKey?_eq_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minEntry?_eq_not_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_eq_not_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minKey?_eq_not_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_eq_not_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minKey?_iff_isEmpty_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_iff_isEmpty_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.replaceEntry_eq_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_eq_map</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_replaceEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minEntry?_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_of_contains</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minEntry?_insert"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_insert</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minEntry?_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minKey?_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getEntry?_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_bind_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_bind_getEntry?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_bind_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_bind_getKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eraseKey_eq_iff_beq_minKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eraseKey_eq_iff_beq_minKey?_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eraseKey_eq_of_beq_minKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eraseKey_eq_of_beq_minKey?_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_insertEntry_le_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntry_le_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntry_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_le_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minKey?_of_isSome_minKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_of_isSome_minKey?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_minKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_le_minKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_le_minKey?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minEntry?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minEntry?_insertIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_insertIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_minKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_insertEntryIfNew_le_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntryIfNew_le_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntryIfNew_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_head?_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_head?_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey?_modifyKey_eq_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_modifyKey_eq_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isSome_minKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_minKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isSome_minKey?_modifyKey_eq_isSome"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_minKey?_modifyKey_eq_isSome</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey?_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eq_get_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_get_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_some_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_insertEntry_le_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntry_le_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntry_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_le_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eraseKey_eq_iff_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eraseKey_eq_iff_beq_minKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eraseKey_eq_of_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eraseKey_eq_of_beq_minKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_le_minKey_erase"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_le_minKey_erase</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_insertEntryIfNew_le_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntryIfNew_le_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntryIfNew_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eq_head_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_head_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey_modifyKey_eq_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_modifyKey_eq_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eq_get!_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_get!_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eq_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_some_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_insertEntry_le_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntry_le_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntry_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_le_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_minKey!_eq_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey!_eq_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eraseKey_eq_iff_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eraseKey_eq_iff_beq_minKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eraseKey_eq_iff_beq_minKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eraseKey_eq_iff_beq_minKey!_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eraseKey_eq_of_beq_minKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eraseKey_eq_of_beq_minKey!_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_le_minKey!_erase"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_le_minKey!_erase</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_insertEntryIfNew_le_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntryIfNew_le_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntryIfNew_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eq_head!_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_head!_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey!_modifyKey_eq_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_modifyKey_eq_minKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey!_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eq_getD_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_getD_minKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey_eq_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey?_eq_some_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKey!_eq_minKeyD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_minKeyD_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_fallback</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_insertEntry_le_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntry_le_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntry_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_le_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_minKeyD_eq_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKeyD_eq_minKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eraseKey_eq_iff_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eraseKey_eq_iff_beq_minKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eraseKey_eq_iff_beq_minKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eraseKey_eq_iff_beq_minKeyD_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eraseKey_eq_of_beq_minKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eraseKey_eq_of_beq_minKeyD_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_le_minKeyD_erase"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_le_minKeyD_erase</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_insertEntryIfNew_le_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntryIfNew_le_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntryIfNew_le_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_eq_headD_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_headD_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.minKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKeyD_modifyKey_eq_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_modifyKey_eq_minKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKeyD_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.minKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_some_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_some_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_none_iff_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_none_iff_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_of_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_of_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isNone_maxKey?_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isNone_maxKey?_eq_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_maxKey?_eq_not_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_eq_not_isEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_maxKey?_iff_isEmpty_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_iff_isEmpty_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_maxKey?_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_bind_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_bind_getKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eraseKey_eq_iff_beq_maxKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eraseKey_eq_iff_beq_maxKey?_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eraseKey_eq_of_beq_maxKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eraseKey_eq_of_beq_maxKey?_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_le_maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le_maxKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey?_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_maxKey?_of_isSome_maxKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_of_isSome_maxKey?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_maxKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey?_eraseKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eraseKey_le_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eraseKey_le_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.isSome_maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_le_maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le_maxKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey?_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.reverse_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">reverse_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_getLast?_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_getLast?_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey?_modifyKey_eq_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_modifyKey_eq_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isSome_maxKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_maxKey?_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.isSome_maxKey?_modifyKey_eq_isSome"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_maxKey?_modifyKey_eq_isSome</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey?_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eq_get_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_get_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_some_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_le_maxKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_le_maxKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_maxKey_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_maxKey_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eraseKey_eq_iff_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eraseKey_eq_iff_beq_maxKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eraseKey_eq_of_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eraseKey_eq_of_beq_maxKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eraseKey_le_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eraseKey_le_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_le_maxKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_le_maxKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eq_getLast_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_getLast_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey_modifyKey_eq_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_modifyKey_eq_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eq_get!_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_get!_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eq_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_some_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_le_maxKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_le_maxKey!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey!_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_maxKey!_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_maxKey!_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_maxKey!_eq_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey!_eq_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eraseKey_eq_iff_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eraseKey_eq_iff_beq_maxKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eraseKey_eq_iff_beq_maxKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eraseKey_eq_iff_beq_maxKey!_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eraseKey_eq_of_beq_maxKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eraseKey_eq_of_beq_maxKey!_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_erase_le_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_erase_le_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_le_maxKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_le_maxKey!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey!_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eq_getLast!_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_getLast!_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey!_modifyKey_eq_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_modifyKey_eq_maxKey!</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey!_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_of_perm</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eq_getD_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_getD_maxKey?</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey_eq_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey?_eq_some_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKey!_eq_maxKeyD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_maxKeyD_default</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_fallback</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_iff_getKey?_eq_self_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_iff_mem_and_forall</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_le_maxKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_le_maxKeyD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKeyD_insertEntry</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.containsKey_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.le_maxKeyD_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_maxKeyD_of_containsKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_le</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey?_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey_maxKeyD_eq_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKeyD_eq_maxKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKey!_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.getKeyD_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eraseKey_eq_iff_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_eq_iff_beq_maxKey_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eraseKey_eq_iff_beq_maxKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_eq_iff_beq_maxKeyD_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eraseKey_eq_of_beq_maxKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_eq_of_beq_maxKeyD_eq_false</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eraseKey_le_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_le_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_le_maxKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_le_maxKeyD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.self_le_maxKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKeyD_insertEntryIfNew</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_eq_getLastD_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_getLastD_keys</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.maxKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_alterKey_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_modifyKey</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKeyD_modifyKey_eq_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_modifyKey_eq_maxKeyD</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKeyD_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_modifyKey_beq</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Internal.List.Const.maxKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_alterKey_eq_self</span></a></div></nav><main>
<div class="mod_doc"><p>This is an internal implementation file of the hash map. Users of the hash map should not rely on
the contents of this file.</p><p>File contents: Verification of associative lists</p></div><div class="decl" id="Std.Internal.List.assoc_induction"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L43-L49">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.assoc_induction"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">assoc_induction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">motive</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <a href="../../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">nil</span> : <span class="fn"><span class="fn">motive</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">cons</span> : <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>) (<span class="fn">tail</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>), <span class="fn"><span class="fn"><span class="fn">motive</span> <span class="fn">tail</span></span> → <span class="fn"><span class="fn">motive</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">tail</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">t</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">t</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L51-L54">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">Std.Internal.List.getEntry?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">Std.Internal.List.getEntry?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">Std.Internal.List.getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getEntry?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getEntry?_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L56-L57">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L58-L59">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eq_find"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L61-L65">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eq_find"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_find</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.find?">List.find?</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_cons_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L67-L69">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L71-L73">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L75-L78">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.beq_of_getEntry?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L80-L90">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.beq_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">beq_of_getEntry?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">p</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L92-L100">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">b</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.keys_eq_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L102-L106">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_eq_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_eq_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eq_some_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L108-L130">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_some_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">e</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">e</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">e</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_iff_getEntry?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L132-L134">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_iff_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getEntry?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">p</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L136-L139">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_isSome_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_iff_forall_isSome_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L141-L144">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_iff_forall_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_iff_forall_isSome_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L150-L153">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValue?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValue?_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L155-L155">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L156-L157">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_cons_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L159-L161">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L163-L165">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L167-L170">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L172-L179">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L181-L183">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">b</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getValue?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L185-L187">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_isSome_getValue?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L191-L195">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValueCast?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValueCast?_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L197-L198">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L199-L201">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_cons_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L203-L206">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L208-L210">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L212-L215">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L217-L219">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_getValueCast?_eq_isSome_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L270-L272">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_getValueCast?_eq_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_getValueCast?_eq_isSome_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L274-L276">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_false_iff_exists_isSome_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_isSome_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L278-L281">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">Std.Internal.List.containsKey</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">Std.Internal.List.containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">Std.Internal.List.containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span>)</li></ul></details><details id="instances-for-list-Std.Internal.List.containsKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.containsKey_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L283-L284">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L285-L286">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_cons_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L288-L290">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_cons_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_cons_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L292-L294">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_cons_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_cons_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L296-L297">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L299-L301">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_cons_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L303-L304">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_cons_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_cons_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L306-L310">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_isSome_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L312-L319">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_isSome_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_true_iff_exists_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L321-L323">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_true_iff_exists_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_true_iff_exists_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">p</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#And">∧</a> (<span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L325-L327">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_contains_map_fst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L329-L336">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_contains_map_fst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_contains_map_fst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.keys_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L338-L338">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></div></div></div></div><div class="decl" id="Std.Internal.List.keys_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L339-L340">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_keys_eq_length"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L342-L343">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_keys_eq_length"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_keys_eq_length</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_keys_eq_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L345-L346">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_keys_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_keys_eq_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_keys_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L348-L352">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_keys_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_keys_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_mem_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L354-L356">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_mem_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_mem_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L358-L360">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L362-L365">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.def"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.perm_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L369-L371">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.perm_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">perm_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l'</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L373-L375">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l'</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L377-L379">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.distinctKeys_of_sublist_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L381-L383">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.distinctKeys_of_sublist_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">distinctKeys_of_sublist_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l'</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.distinctKeys_of_sublist"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L385-L387">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.distinctKeys_of_sublist"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">distinctKeys_of_sublist</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l'</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.of_keys_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L389-L391">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.of_keys_eq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">of_keys_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_iff_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L393-L395">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_iff_exists"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_iff_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">a'</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn">a'</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_false_iff_forall_mem_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L397-L400">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_false_iff_forall_mem_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_false_iff_forall_mem_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a'</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> → (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_false_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L402-L404">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_false_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_false_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>), <span class="fn"><span class="fn">b</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> → (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.distinctKeys_cons_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L406-L413">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.distinctKeys_cons_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">distinctKeys_cons_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.tail"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L415-L417">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.tail"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">tail</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L419-L421">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L423-L425">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_false_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L427-L429">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_false_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_false_iff_exists_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L431-L433">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_false_iff_exists_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_iff_exists_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">a</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_iff_forall_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L435-L437">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_iff_forall_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eq_none"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L439-L442">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_none</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_none"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L444-L447">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_none</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_isSome_getValue?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L449-L451">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_isSome_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getValue?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_isSome_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L453-L455">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_isSome_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_getValueCast?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L457-L460">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_getValueCast?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_getValueCast?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_getValue_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L462-L465">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_getValue_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_getValue_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_eq_none"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L467-L469">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_none</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L471-L473">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">b</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L475-L477">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hla</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L479-L481">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">Std.Internal.List.getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">Std.Internal.List.getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getEntry" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getEntry?_eq_some_getEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L483-L485">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eq_some_getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_some_getEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_eq_of_getEntry?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L487-L489">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_eq_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_eq_of_getEntry?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_cons_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L491-L493">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_cons_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L495-L498">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L500-L503">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">h₁</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L505-L518">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L520-L535">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L541-L543">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">Std.Internal.List.getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_some_getValue"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L545-L547">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_some_getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_getValue</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_cons_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L549-L551">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L553-L556">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L558-L561">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">h₁</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L563-L570">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn">v</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L572-L575">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">b</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L577-L588">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_eq_getEntry_snd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L590-L592">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_eq_getEntry_snd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getEntry_snd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h'</span>)</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L596-L599">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">Std.Internal.List.getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValueCast" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValueCast?_eq_some_getValueCast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L601-L603">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_eq_some_getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_some_getValueCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L605-L613">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L615-L631">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">a</span>, <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L633-L648">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_eq_getValueCast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L650-L654">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_eq_getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getValueCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L656-L658">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">Std.Internal.List.getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValueCastD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValueCastD_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L660-L662">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_eq_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L664-L665">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eq_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_eq_fallback"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L667-L671">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eq_fallback</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_eq_getValueCastD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L673-L676">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_eq_getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eq_getValueCastD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_eq_some_getValueCastD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L678-L681">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_eq_some_getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_some_getValueCastD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L683-L686">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">Std.Internal.List.getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValueCast!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValueCast!_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L688-L690">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_eq_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L692-L693">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eq_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_eq_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L695-L699">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eq_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_eq_getValueCast!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L701-L703">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_eq_getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eq_getValueCast!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_eq_some_getValueCast!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L705-L708">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_eq_some_getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eq_some_getValueCast!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_eq_getValueCastD_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L710-L711">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_eq_getValueCastD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eq_getValueCastD_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L717-L719">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fallback</span> : <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">Std.Internal.List.getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValueD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValueD_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L721-L723">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_eq_getValue?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L725-L726">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_eq_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eq_getValue?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_eq_fallback"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L728-L731">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eq_fallback</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_eq_getValueD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L733-L735">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_eq_getValueD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getValueD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_some_getValueD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L737-L739">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_some_getValueD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_getValueD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_eq_getValueCastD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L741-L743">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_eq_getValueCastD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eq_getValueCastD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L745-L747">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">b</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L749-L751">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">Std.Internal.List.getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getValue!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getValue!_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L753-L755">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_eq_getValue?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L757-L758">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_eq_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_getValue?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_eq_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L760-L763">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_eq_getValue!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L765-L767">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_eq_getValue!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eq_getValue!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_some_getValue!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L769-L771">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_some_getValue!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_getValue!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_eq_getValueCast!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L773-L775">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_eq_getValueCast!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_getValueCast!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L777-L779">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">b</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_eq_getValueD_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L781-L782">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_eq_getValueD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eq_getValueD_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L786-L789">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">Std.Internal.List.getKey?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">Std.Internal.List.getKey?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">Std.Internal.List.getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getKey?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getKey?_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L791-L792">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L794-L795">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_cons_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L797-L799">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_cons_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L801-L803">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L805-L812">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.fst_mem_keys_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L814-L816">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.fst_mem_keys_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">fst_mem_keys_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hm</span> : <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_some_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L818-L828">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L830-L836">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.all">Option.all</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L838-L843">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eq_isSome_getKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L845-L847">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eq_isSome_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eq_isSome_getKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eq_some_iff_getKey?_eq_some_getValue?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L849-L859">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eq_some_iff_getKey?_eq_some_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_some_iff_getKey?_eq_some_getValue?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L861-L867">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">a'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L869-L871">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">Std.Internal.List.getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">Std.Internal.List.getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_some_getKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L873-L875">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_some_getKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_getKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L877-L884">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>) <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn">k</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L886-L888">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L890-L893">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_eq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L895-L897">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L899-L901">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h''</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">h''</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L903-L933">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_eq_getEntry_fst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L935-L937">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_eq_getEntry_fst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq_getEntry_fst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.forall_mem_keys_iff_forall_containsKey_getKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L939-L974">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.forall_mem_keys_iff_forall_containsKey_getKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forall_mem_keys_iff_forall_containsKey_getKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> → <span class="fn"><span class="fn">p</span> <span class="fn">k</span></span></span>)</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">p</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L976-L978">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fallback</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">Std.Internal.List.getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">Std.Internal.List.getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getKeyD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getKeyD_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L980-L982">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_eq_getKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L984-L985">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_eq_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eq_getKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_eq_fallback"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L987-L991">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eq_fallback</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_eq_getKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L993-L996">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_eq_getKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq_getKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L998-L1000">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_eq_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1002-L1005">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_eq_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eq_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_some_getKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1007-L1010">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_some_getKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_getKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1012-L1014">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">Std.Internal.List.getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">Std.Internal.List.getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></li></ul></details><details id="instances-for-list-Std.Internal.List.getKey!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.getKey!_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1016-L1018">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_eq_getKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1020-L1021">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_eq_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_getKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_eq_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1023-L1027">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_eq_getKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1029-L1031">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_eq_getKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eq_getKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1033-L1035">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_eq_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1037-L1040">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_eq_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_some_getKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1042-L1045">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_some_getKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_some_getKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_eq_getKeyD_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1047-L1048">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_eq_getKeyD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eq_getKeyD_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eq_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1050-L1061">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eq_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eq_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">a</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_eq_getKey_getValue"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1063-L1074">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_eq_getKey_getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_eq_getKey_getValue</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span>, <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1076-L1079">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">Std.Internal.List.replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">Std.Internal.List.replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k_1</span>, <span class="fn">v_1</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">bif <span class="fn">k_1</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span> then <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span> else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k_1</span>, <span class="fn">v_1</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">Std.Internal.List.replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.replaceEntry" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.replaceEntry_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1081-L1081">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1082-L1084">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span> then <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span> else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_cons_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1086-L1088">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_cons_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_cons_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1090-L1093">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1095-L1101">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1103-L1109">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_replaceEntry_of_beq_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1111-L1124">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_replaceEntry_of_beq_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_replaceEntry_of_beq_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : (<span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_replaceEntry_of_key_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1126-L1129">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_replaceEntry_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_replaceEntry_of_key_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_replaceEntry_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1131-L1134">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_replaceEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_replaceEntry_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1136-L1146">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_replaceEntry_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_replaceEntry_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1148-L1159">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1161-L1169">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1171-L1178">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry_replaceEntry_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1180-L1185">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry_replaceEntry_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">hl</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></div></div></div></div><div class="decl" id="Std.Internal.List.mem_getEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1187-L1196">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_getEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">hl</span></span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_replaceEntry_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1198-L1204">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_replaceEntry_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1206-L1209">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_replaceEntry_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1215-L1217">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_replaceEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_replaceEntry_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_replaceEntry_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1219-L1222">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_replaceEntry_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_replaceEntry_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_replaceEntry_of_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1224-L1227">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_replaceEntry_of_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_replaceEntry_of_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1231-L1245">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1247-L1257">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1259-L1262">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">Std.Internal.List.eraseKey</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">Std.Internal.List.eraseKey</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k_1</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k_1</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span> then <span class="fn">l</span> else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k_1</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">Std.Internal.List.eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.eraseKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.eraseKey_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1264-L1264">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1266-L1267">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span> then <span class="fn">l</span> else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_cons_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1269-L1271">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1273-L1276">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1278-L1280">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1282-L1288">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_eraseKey_of_key_beq_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1290-L1305">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_eraseKey_of_key_beq_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_eraseKey_of_key_beq_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : (<span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_eraseKey_of_key_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1307-L1309">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_eraseKey_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_eraseKey_of_key_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.sublist_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1311-L1319">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.sublist_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">sublist_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1321-L1336">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_eraseKey_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1338-L1340">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_eraseKey_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_eraseKey_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_le_length_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1342-L1345">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_le_length_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1347-L1352">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1354-L1366">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">List.replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1368-L1378">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hk</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkv</span> : <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1380-L1382">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">Std.Internal.List.insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">bif <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">Std.Internal.List.containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> then <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">Std.Internal.List.replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.insertEntry" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.insertEntry_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1384-L1387">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#List.cons">[</a><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a><a href="../../../.././Init/Prelude.html#List.cons">]</a></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_cons_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1389-L1395">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_cons_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_cons_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>))</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span>)</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_cons_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1397-L1399">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_cons_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_cons_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_cons_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1401-L1404">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_cons_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_cons_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#ReflBEq">ReflBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1406-L1408">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1410-L1412">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_insertEntry_of_key_beq_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1414-L1422">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_insertEntry_of_key_beq_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_insertEntry_of_key_beq_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : (<span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_insertEntry_of_key_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1424-L1427">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_insertEntry_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_insertEntry_of_key_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1429-L1435">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">List.insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1437-L1442">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1444-L1446">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.length_le_length_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1448-L1451">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_le_length_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertEntry_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1453-L1456">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertEntry_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntry_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertEntry_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1462-L1466">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertEntry_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertEntry_of_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1468-L1470">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertEntry_of_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_of_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertEntry_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1472-L1476">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertEntry_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1478-L1482">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1484-L1486">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1490-L1495">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1497-L1503">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1505-L1507">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1509-L1512">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1514-L1516">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1518-L1523">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1525-L1527">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback </span><span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1529-L1532">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1534-L1536">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1538-L1541">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback </span><span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1543-L1545">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback </span><span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1547-L1552">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1554-L1556">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eq_none"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1558-L1560">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eq_none"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eq_none</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1562-L1565">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1567-L1569">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1571-L1574">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1576-L1578">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1580-L1584">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertEntry_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1586-L1588">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertEntry_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntry_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1590-L1592">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1594-L1597">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1599-L1605">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1607-L1609">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1611-L1617">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn">v</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1619-L1621">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1623-L1628">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn">k</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertEntry_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1630-L1632">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertEntry_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertEntry_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntryIfNew"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1634-L1636">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">Std.Internal.List.insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">bif <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">Std.Internal.List.containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> then <span class="fn">l</span> else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.insertEntryIfNew" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.insertEntryIfNew_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1638-L1640">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntryIfNew_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1642-L1644">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1646-L1654">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">List.insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1656-L1662">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1664-L1669">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1671-L1678">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1680-L1684">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1686-L1697">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertEntryIfNew_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1699-L1701">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertEntryIfNew_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertEntryIfNew_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1703-L1706">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_insertEntryIfNew'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1708-L1718">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_insertEntryIfNew'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertEntryIfNew'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <a href="../../../.././Init/Prelude.html#Not">¬</a>((<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>))</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div><p>This is a restatement of <code><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertEntryIfNew">containsKey_insertEntryIfNew</a></code> that is written to exactly match the proof
obligation in the statement of <code><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_insertEntryIfNew">getValueCast_insertEntryIfNew</a></code>.</p></div></div><div class="decl" id="Std.Internal.List.getValueCast_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1720-L1728">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1730-L1736">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> then <span class="fn">v</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1738-L1742">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1744-L1747">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1749-L1754">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1756-L1760">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback </span><span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">v</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1762-L1768">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1770-L1776">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h' : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> then <span class="fn">k</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1778-L1781">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1783-L1786">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1788-L1790">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.length_le_length_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1792-L1795">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_le_length_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertEntryIfNew_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1797-L1800">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertEntryIfNew_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertEntryIfNew_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.keys_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1802-L1810">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.erase">erase</a></span> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1812-L1814">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">List.eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1816-L1826">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eraseKey_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1828-L1830">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eraseKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hka</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eraseKey_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1832-L1844">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eraseKey_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hka</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1846-L1851">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.keys_filterMap'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1853-L1860">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_filterMap'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_filterMap'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_keys_iff_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1862-L1868">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_keys_iff_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_keys_iff_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.keys_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1870-L1890">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <a href="../../../.././Init/Prelude.html#Subtype">{</a> <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Subtype">:</a> <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Subtype">//</a> <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Subtype">}</a>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Prelude.html#Subtype.val">val</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Prelude.html#Subtype.val">val</a></span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span>)</span> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Attach.html#List.attach">attach</a></span>)</span>.<a href="../../../.././Init/Data/List/Attach.html#List.unattach">unattach</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.keys_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1892-L1912">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.keys_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">keys_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <a href="../../../.././Init/Prelude.html#Subtype">{</a> <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Subtype">:</a> <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Subtype">//</a> <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Subtype">}</a>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Prelude.html#Subtype.val">val</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Prelude.html#Subtype.val">val</a></span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span>)</span> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Attach.html#List.attach">attach</a></span>)</span>.<a href="../../../.././Init/Data/List/Attach.html#List.unattach">unattach</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.keys_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1914-L1917">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.keys_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">keys_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1919-L1925">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> →
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1927-L1929">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1931-L1933">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1939-L1941">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eraseKey_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1943-L1945">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eraseKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hka</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eraseKey_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1947-L1949">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eraseKey_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hka</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1951-L1954">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1958-L1964">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1966-L1968">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1970-L1973">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1975-L1977">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1979-L1982">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1984-L1986">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1988-L1990">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eraseKey_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1992-L1994">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eraseKey_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hka</span> : (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eraseKey_of_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L1996-L1998">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eraseKey_of_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey_of_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hka</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2000-L2002">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_isEmpty_eraseKey_and_not_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2004-L2017">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_isEmpty_eraseKey_and_not_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_isEmpty_eraseKey_and_not_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_eq_false_of_isEmpty_eraseKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2019-L2023">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_eq_false_of_isEmpty_eraseKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_eq_false_of_isEmpty_eraseKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2025-L2031">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2033-L2035">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2037-L2040">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2042-L2044">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2046-L2050">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2052-L2055">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2057-L2060">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2062-L2065">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2067-L2070">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_eraseKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2072-L2075">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_eraseKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_eraseKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2077-L2079">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2081-L2086">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2088-L2093">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2095-L2100">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2102-L2116">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2118-L2126">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2128-L2130">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2132-L2136">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2138-L2141">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2143-L2146">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2152-L2154">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2156-L2160">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2162-L2164">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2166-L2169">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2173-L2175">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2177-L2181">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2183-L2186">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">a</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2188-L2191">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.perm_cons_getEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2193-L2203">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.perm_cons_getEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_cons_getEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">l'</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry">getEntry</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l'</span>)</span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2206-L2224">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2226-L2230">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_getValue?_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2232-L2248">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_getValue?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_getValue?_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hk</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>) (<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l'</span> <span class="fn">h'</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hv</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_getValue?_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2250-L2256">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_getValue?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_getValue?_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hk</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hv</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2258-L2270">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2272-L2279">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_ext"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2281-L2284">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2286-L2289">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntryIfNew_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2291-L2295">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntryIfNew_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2297-L2300">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_append"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2302-L2307">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_append"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_append</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.or">or</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2309-L2311">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_append"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2313-L2316">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_append"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_append</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_flatMap_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2318-L2329">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_flatMap_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_flatMap_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">γ</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">i</span> : <a href="../../../.././Init/Prelude.html#Nat">Nat</a>) (<span class="fn">h</span> : <span class="fn">i</span> <a href="../../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<span class="fn">f</span> <span class="fn">l</span><a href="../../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">i</span><a href="../../../.././Init/GetElem.html#GetElem.getElem">]</a>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.flatMap">List.flatMap</a> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_append_of_not_contains_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2331-L2333">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_append_of_not_contains_right"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_append_of_not_contains_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_append"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2335-L2338">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_append"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_append</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.or">or</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2340-L2342">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2344-L2348">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>) <span class="fn">h'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2350-L2353">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2355-L2360">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>) <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2362-L2365">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_append_of_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2367-L2372">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_append_of_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_append_of_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>) <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_append_of_containsKey_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2374-L2382">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_append_of_containsKey_left"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_append_of_containsKey_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_append_of_containsKey_left_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2384-L2391">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_append_of_containsKey_left_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_append_of_containsKey_left_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_append_of_containsKey_right_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2393-L2399">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_append_of_containsKey_right_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertEntry_append_of_not_contains_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2401-L2406">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry_append_of_not_contains_right"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertEntry_append_of_not_contains_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span></div></div></div></div><div class="decl" id="Std.Internal.List.eraseKey_append_of_containsKey_right_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2408-L2416">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eraseKey_append_of_containsKey_right_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_iff_getValueCast?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2418-L2427">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_iff_getValueCast?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getValueCast?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.find?_eq_some_iff_getValueCast?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2429-L2433">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.find?_eq_some_iff_getValueCast?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_eq_some_iff_getValueCast?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.find?">List.find?</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.find?_eq_none_iff_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2435-L2438">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.find?_eq_none_iff_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_eq_none_iff_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.find?">List.find?</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.pairwise_fst_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2440-L2443">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.pairwise_fst_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">pairwise_fst_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.map_fst_map_toProd_eq_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2445-L2451">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.map_fst_map_toProd_eq_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">map_fst_map_toProd_eq_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.find?_map_eq_none_iff_containsKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2453-L2457">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.find?_map_eq_none_iff_containsKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_map_eq_none_iff_containsKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.find?">List.find?</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.mem_map_toProd_iff_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2459-L2467">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_map_toProd_iff_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_map_toProd_iff_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_iff_getValue?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2469-L2479">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_iff_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getValue?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_map_toProd_iff_getValue?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2481-L2485">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_map_toProd_iff_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_map_toProd_iff_getValue?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.find?_map_toProd_eq_some_iff_getKey?_eq_some_and_getValue?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2487-L2500">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.find?_map_toProd_eq_some_iff_getKey?_eq_some_and_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">find?_map_toProd_eq_some_iff_getKey?_eq_some_and_getValue?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.find?">List.find?</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k'</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_iff_getKey?_eq_some_and_getValue?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2502-L2505">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_iff_getKey?_eq_some_and_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_iff_getKey?_eq_some_and_getValue?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_eq_some_iff_exists_beq_and_mem_toList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2507-L2521">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_eq_some_iff_exists_beq_and_mem_toList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_eq_some_iff_exists_beq_and_mem_toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">k'</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k'</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_map_toProd_iff_getKey?_eq_some_and_getValue?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2524-L2528">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_map_toProd_iff_getKey?_eq_some_and_getValue?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_map_toProd_iff_getKey?_eq_some_and_getValue?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.pairwise_fst_eq_false_map_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2530-L2535">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.pairwise_fst_eq_false_map_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">pairwise_fst_eq_false_map_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldlM_eq_foldlM_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2537-L2543">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldlM_eq_foldlM_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldlM_eq_foldlM_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">δ</span></span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldlM">List.foldlM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">δ</span>) (<span class="fn">b</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldlM">List.foldlM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">δ</span>) (<span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldl_eq_foldl_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2545-L2551">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldl_eq_foldl_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldl_eq_foldl_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List.foldl">List.foldl</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">δ</span>) (<span class="fn">b</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#List.foldl">List.foldl</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">δ</span>) (<span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldrM_eq_foldrM_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2553-L2559">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldrM_eq_foldrM_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">δ</span></span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span> <span class="fn">b</span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span> <span class="fn">b</span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldrM_eq_foldrM_toProd'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2561-L2567">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldrM_eq_foldrM_toProd'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_toProd'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">δ</span></span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldr_eq_foldr_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2569-L2575">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldr_eq_foldr_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span> <span class="fn">b</span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span> <span class="fn">b</span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldr_eq_foldr_toProd'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2577-L2583">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldr_eq_foldr_toProd'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_toProd'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.forM_eq_forM_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2585-L2590">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.forM_eq_forM_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forM_eq_forM_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">m'</span> <a href="../../../.././Init/Prelude.html#PUnit">PUnit</a></span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../../../.././Init/Control/Basic.html#ForM.forM">forM</a> <span class="fn">l</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Control/Basic.html#ForM.forM">forM</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.forIn_eq_forIn_toProd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2592-L2598">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.forIn_eq_forIn_toProd"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forIn_eq_forIn_toProd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">(<a href="../../../.././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">δ</span>)</span></span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../../../.././Init/Core.html#ForIn.forIn">forIn</a> <span class="fn">l</span> <span class="fn">init</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) (<span class="fn">d</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span> <span class="fn">d</span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Core.html#ForIn.forIn">forIn</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span> <span class="fn">init</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) (<span class="fn">d</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span> <span class="fn">d</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldlM_eq_foldlM_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2600-L2608">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldlM_eq_foldlM_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldlM_eq_foldlM_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldlM">List.foldlM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">δ</span>) (<span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldlM">List.foldlM</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldl_eq_foldl_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2610-L2615">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldl_eq_foldl_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldl_eq_foldl_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn">δ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List.foldl">List.foldl</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">δ</span>) (<span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#List.foldl">List.foldl</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldrM_eq_foldrM_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2617-L2623">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldrM_eq_foldrM_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">b</span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldrM_eq_foldrM_keys'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2625-L2631">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldrM_eq_foldrM_keys'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldrM_eq_foldrM_keys'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">δ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Control.html#List.foldrM">List.foldrM</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn">a</span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldr_eq_foldr_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2633-L2638">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldr_eq_foldr_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn">δ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">b</span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">f</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.foldr_eq_foldr_keys'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2640-L2645">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.foldr_eq_foldr_keys'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">foldr_eq_foldr_keys'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">α</span> → <span class="fn">δ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">init</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">b</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">b</span> <span class="fn">a</span></span>)</span> <span class="fn">init</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.forM_eq_forM_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2647-L2656">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.forM_eq_forM_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forM_eq_forM_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">m'</span> <a href="../../../.././Init/Prelude.html#PUnit">PUnit</a></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Control.html#List.forM">forM</a></span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Control.html#List.forM">forM</a></span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.forIn_eq_forIn_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2658-L2667">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.forIn_eq_forIn_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forIn_eq_forIn_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">δ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">m'</span> : <span class="fn"><a href="../../../.././foundational_types.html">Type</a> w → <a href="../../../.././foundational_types.html">Type</a> w'</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Monad">Monad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Control/Lawful/Basic.html#LawfulMonad">LawfulMonad</a> <span class="fn">m'</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn"><span class="fn">m'</span> <span class="fn">(<a href="../../../.././Init/Core.html#ForInStep">ForInStep</a> <span class="fn">δ</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">init</span> : <span class="fn">δ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../../../.././Init/Core.html#ForIn.forIn">forIn</a> <span class="fn">l</span> <span class="fn">init</span> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) (<span class="fn">d</span> : <span class="fn">δ</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">d</span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Core.html#ForIn.forIn">forIn</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span> <span class="fn">init</span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2669-L2673">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">Std.Internal.List.insertList</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">Std.Internal.List.insertList</a> <span class="fn">l</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l_1</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">Std.Internal.List.insertList</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">Std.Internal.List.insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">l_1</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.insertList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2675-L2682">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l₁</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">List.insertList</a> <span class="fn">l₁</span> <span class="fn">l₂</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertList_perm_of_perm_first"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2684-L2691">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList_perm_of_perm_first"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertList_perm_of_perm_first</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l1 </span><span class="fn">l2 </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l1</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l2</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l1</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l1</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l2</span> <span class="fn">toInsert</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.insertList_cons_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2693-L2711">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList_cons_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertList_cons_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₂</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> (<span class="fn">p</span> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l₂</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l₁</span> (<span class="fn">p</span> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l₂</span>))</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l₁</span> <span class="fn">l₂</span>)</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2713-L2728">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.or">or</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2730-L2740">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">toInsert</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertList_of_contains_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2742-L2750">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertList_of_contains_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertList_of_contains_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">contains</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">toInsert</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">toInsert</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2752-L2764">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2766-L2769">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2771-L2777">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2779-L2794">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2796-L2804">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2806-L2816">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2818-L2823">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2825-L2834">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k'</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2836-L2841">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_mem</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2843-L2852">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2854-L2860">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2862-L2872">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2874-L2881">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2883-L2892">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2894-L2898">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">contains_false</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2900-L2908">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertList_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2910-L2914">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertList_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertList_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2916-L2924">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertList_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.perm_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2926-L2943">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.perm_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_both</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">toInsert</span>)</span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2945-L2951">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_both</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_le_length_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2953-L2958">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_le_length_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertList_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2960-L2969">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertList_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertList_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_insertList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2971-L2978">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_insertList"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">insertList</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.Prod.toSigma"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2984-L2985">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Prod.toSigma"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Prod</span>.<span class="name">toSigma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Prod.toSigma">Std.Internal.List.Prod.toSigma</a> <span class="fn">p</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>, <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Prelude.html#Prod.snd">snd</a></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></li></ul></details><details id="instances-for-list-Std.Internal.List.Prod.toSigma" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.Prod.fst_comp_toSigma"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2987-L2991">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Prod.fst_comp_toSigma"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Prod</span>.<span class="name">fst_comp_toSigma</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <a href="../../../.././Init/Prelude.html#Function.comp">∘</a> <a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Prod.toSigma">toSigma</a> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a></div></div></div></div><div class="decl" id="Std.Internal.List.insertListConst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2993-L2995">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertListConst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">Std.Internal.List.insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertList">Std.Internal.List.insertList</a> <span class="fn">l</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Prod.toSigma">Std.Internal.List.Prod.toSigma</a> <span class="fn">toInsert</span>)</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.insertListConst" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.containsKey_insertListConst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L2997-L3003">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertListConst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_insertListConst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3005-L3011">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertListConst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3013-L3019">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3021-L3032">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3034-L3041">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3043-L3052">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3054-L3059">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3061-L3069">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3071-L3076">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3078-L3086">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertListConst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3088-L3098">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListConst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_both</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_le_length_insertListConst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3100-L3105">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_le_length_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertListConst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertListConst_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3107-L3112">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertListConst_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListConst_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_insertListConst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3114-L3119">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_insertListConst"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertListConst</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3121-L3128">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3130-L3155">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3157-L3164">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3166-L3175">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3177-L3182">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue!_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3184-L3192">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue!_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_insertListConst_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3194-L3199">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_insertListConst_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertListConst_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <a href="../../../.././Init/Prelude.html#Prod.fst">Prod.fst</a> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueD_insertListConst_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3201-L3209">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD_insertListConst_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueD_insertListConst_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> (<span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>)</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v </span><span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span> <a href="../../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span>) =&gt; (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Prelude.html#Prod.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn">k</span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn">v</span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListConst">insertListConst</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">v</span></div></div></div></div><div class="decl" id="Std.Internal.List.insertListIfNewUnit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3211-L3216">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">Std.Internal.List.insertListIfNewUnit</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></li><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">Std.Internal.List.insertListIfNewUnit</a> <span class="fn">l</span> (<span class="fn">hd</span> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">tl</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">Std.Internal.List.insertListIfNewUnit</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">Std.Internal.List.insertEntryIfNew</a> <span class="fn">hd</span> <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a> <span class="fn">l</span>)</span> <span class="fn">tl</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.insertListIfNewUnit" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.insertListIfNewUnit_perm_of_perm_first"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3218-L3234">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit_perm_of_perm_first"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">insertListIfNewUnit_perm_of_perm_first</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l1 </span><span class="fn">l2</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l1</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l2</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l1</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l1</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l2</span> <span class="fn">toInsert</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3236-L3243">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">List.insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3245-L3265">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.or">or</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">x</span>, <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">toInsert</span>)</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.mapUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3267-L3272">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.mapUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">mapUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">x</span>, <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_insertListIfNewUnit_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3274-L3287">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_insertListIfNewUnit_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_insertListIfNewUnit_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">not_contains</span> : <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3289-L3297">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3299-L3304">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3306-L3312">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertListIfNewUnit_of_contains_eq_false_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3314-L3330">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem'</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_insertListIfNewUnit_of_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3332-L3338">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_insertListIfNewUnit_of_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertListIfNewUnit_of_contains_eq_false_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3340-L3348">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">contains_eq_false</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_insertListIfNewUnit_of_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3350-L3356">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_insertListIfNewUnit_of_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">contains</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">contains</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3358-L3365">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">contains_eq_false</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">contains_eq_false'</span> : <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertListIfNewUnit_of_contains_eq_false_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3367-L3374">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_insertListIfNewUnit_of_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3376-L3381">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_insertListIfNewUnit_of_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3383-L3389">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListIfNewUnit_of_contains_eq_false_of_contains_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">contains_eq_false</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">contains_eq_false'</span> : <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains_eq_false_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3391-L3398">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains_eq_false_of_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListIfNewUnit_of_contains_eq_false_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k_beq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">mem</span> : <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">toInsert</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3400-L3406">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_insertListIfNewUnit_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_insertListIfNewUnit_of_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">contains</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3408-L3451">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct_l</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_toInsert</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">α</span>) =&gt; (<span class="fn">a</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">b</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span> <span class="fn">toInsert</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">distinct_both</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_le_length_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3453-L3458">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_le_length_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_le_length_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_insertListIfNewUnit_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3460-L3470">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_insertListIfNewUnit_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_insertListIfNewUnit_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3472-L3479">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_list_unit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3481-L3489">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_list_unit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_list_unit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValue?_insertListIfNewUnit"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3491-L3495">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?_insertListIfNewUnit"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue?_insertListIfNewUnit</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#PartialEquivBEq">PartialEquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <a href="../../../.././Init/Prelude.html#Unit">Unit</a>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">toInsert</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertListIfNewUnit">insertListIfNewUnit</a> <span class="fn">l</span> <span class="fn">toInsert</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><span class="fn">toInsert</span>.<a href="../../../.././Init/Data/List/Basic.html#List.contains">contains</a></span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <a href="../../../.././Init/Prelude.html#Unit.unit">(</a><a href="../../../.././Init/Prelude.html#Unit.unit">)</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.alterKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3514-L3519">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">Std.Internal.List.alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> with
  | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">Std.Internal.List.eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span>
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">Std.Internal.List.insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.alterKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.length_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3521-L3529">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>
  else <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <a href="../../../.././Init/Prelude.html#Option.none">none</a>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_alterKey'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3531-L3540">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_alterKey'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_alterKey'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>
  <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.alterKey_cons_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3542-L3561">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey_cons_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_cons_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>))</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span>
  <span class="fn">(if hk : (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then
    <span class="fn">match <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">v'</span>)</span>)</span></span> with
    | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn">l</span>
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></span>
  else <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_alterKey_eq_isEmpty_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3563-L3568">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_alterKey_eq_isEmpty_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_alterKey_eq_isEmpty_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3570-L3573">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> ((<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.alterKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3575-L3580">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.alterKey_append_of_containsKey_right_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3582-L3587">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_append_of_containsKey_right_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span></div></div></div></div><div class="decl" id="Std.Internal.List.alterKey_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3589-L3593">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">alterKey_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">f</span> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span> with
  | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a>
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">b</span></span> =&gt; <a href="../../../.././Init/Prelude.html#List.cons">[</a><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">a</span>, <span class="fn">b</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a><a href="../../../.././Init/Prelude.html#List.cons">]</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_alterKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3595-L3606">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_alterKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3608-L3622">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3624-L3629">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">List.alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.mem_alterKey_of_key_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3631-L3635">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.mem_alterKey_of_key_ne"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">mem_alterKey_of_key_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">a</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Core.html#Ne">≠</a> <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3637-L3660">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k'</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3662-L3682">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_alterKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3684-L3690">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_alterKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3692-L3703">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k'</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k'</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3705-L3712">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span>
  else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3714-L3722">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3724-L3736">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3738-L3756">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn">k</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3758-L3769">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.alterKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3779-L3784">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">Std.Internal.List.Const.alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> with
  | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">Std.Internal.List.eraseKey</a> <span class="fn">k</span> <span class="fn">l</span></span>
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">Std.Internal.List.insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.Const.alterKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.Const.length_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3786-L3794">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>
  else <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <a href="../../../.././Init/Prelude.html#Option.none">none</a>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_alterKey'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3796-L3805">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_alterKey'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span>
  <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_alterKey_eq_add_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3807-L3810">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_alterKey_eq_add_one"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_add_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_alterKey_eq_sub_one"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3812-L3815">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_alterKey_eq_sub_one"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_sub_one</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3817-L3820">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_alterKey_eq_self'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3822-L3825">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_alterKey_eq_self'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_alterKey_eq_self'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.alterKey_cons_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3827-L3847">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey_cons_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_cons_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v'</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> (<a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>))</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span>
  (<a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k'</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a>
    <span class="fn">match <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v'</span>)</span></span> with
    | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn">l</span>
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></span>
  <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k'</span>, <span class="fn">v'</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span>)</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_alterKey_eq_isEmpty_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3849-L3853">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_alterKey_eq_isEmpty_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_alterKey_eq_isEmpty_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3855-L3858">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> ((<span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Bool.or">||</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">1</span> <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Bool.and">&amp;&amp;</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span>)</div></div></div></div><div class="decl" id="Std.Internal.List.Const.alterKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3860-L3866">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.alterKey_append_of_containsKey_right_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3868-L3873">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey_append_of_containsKey_right_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_append_of_containsKey_right_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> (<span class="fn">l</span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">l'</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.alterKey_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3875-L3879">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">alterKey_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">f</span> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span> with
  | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a>
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">b</span></span> =&gt; <a href="../../../.././Init/Prelude.html#List.cons">[</a><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">a</span>, <span class="fn">b</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a><a href="../../../.././Init/Prelude.html#List.cons">]</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_alterKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3881-L3894">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_alterKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.mem_alterKey_of_key_not_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3896-L3901">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.mem_alterKey_of_key_not_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">mem_alterKey_of_key_not_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hne</span> : (<span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">a</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">p</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3903-L3920">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3922-L3943">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3945-L3963">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue_alterKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3965-L3970">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue_alterKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_alterKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3972-L3980">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3982-L3990">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey?_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L3992-L4000">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey?_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey!_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4002-L4009">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey!_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4011-L4028">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn">k</span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKeyD_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4030-L4041">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKeyD_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.constAlterKey_eq_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4045-L4048">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.constAlterKey_eq_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">constAlterKey_eq_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">Const.alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.constAlterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4050-L4056">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.constAlterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">constAlterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">Const.alterKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.modifyKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4062-L4067">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">Std.Internal.List.modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">Std.Internal.List.getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span></span> with
  | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn">l</span>
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">Std.Internal.List.replaceEntry</a> <span class="fn">k</span> <span class="fn">(<span class="fn">f</span> <span class="fn">v</span>)</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.modifyKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.isEmpty_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4069-L4075">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4077-L4083">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4085-L4092">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.modifyKey_eq_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4094-L4098">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey_eq_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">modifyKey_eq_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">x</span></span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4100-L4102">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">List.modifyKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.modifyKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4104-L4107">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">modifyKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4109-L4116">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k'</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4118-L4122">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4124-L4139">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4141-L4146">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4148-L4155">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">hi</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k'</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k'</span> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4157-L4161">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4163-L4170">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k'</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span>
  else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4172-L4176">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4178-L4185">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4187-L4190">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4192-L4199">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4201-L4204">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4206-L4214">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4216-L4220">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span> → <span class="fn">∀ (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4222-L4229">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4231-L4234">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.modifyKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4240-L4245">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span></div></div><p>Internal implementation detail of the hash map</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">Std.Internal.List.Const.modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">Std.Internal.List.getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> with
  | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn">l</span>
  | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span> =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">Std.Internal.List.replaceEntry</a> <span class="fn">k</span> <span class="fn">(<span class="fn">f</span> <span class="fn">v</span>)</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.Const.modifyKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4247-L4253">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.modifyKey_eq_alterKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4255-L4259">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey_eq_alterKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">modifyKey_eq_alterKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">x</span></span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.modifyKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4261-L4264">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">modifyKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l'</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4266-L4272">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4274-L4281">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4283-L4290">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4292-L4295">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4297-L4311">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if heq : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span> else <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4313-L4318">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4320-L4326">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">hi</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4328-L4332">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4334-L4341">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4343-L4347">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4349-L4356">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey?_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4358-L4361">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey?_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4363-L4369">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k'</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey!_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4371-L4374">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey!_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4376-L4385">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4387-L4391">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKeyD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4393-L4400">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k' </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k'</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">fallback</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k'</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKeyD_modifyKey_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4402-L4405">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKeyD_modifyKey_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_modifyKey_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.constModifyKey_eq_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4409-L4413">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.constModifyKey_eq_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">constModifyKey_eq_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">Const.modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.constModifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4415-L4417">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.constModifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">constModifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">Const.modifyKey</a> <span class="fn">a</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.guard_eq_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4463-L4466">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.guard_eq_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">guard_eq_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span> → <a href="../../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.guard">Option.guard</a> <span class="fn">fun (<span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(<span class="fn">p</span> <span class="fn">b</span>)</span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt;
  <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">y</span> : <span class="fn"><span class="fn">β</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">y</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> (<a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Sigma.snd_congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4468-L4470">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Sigma.snd_congr"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Sigma</span>.<span class="name">snd_congr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x </span><span class="fn">x'</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x'</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn"><span class="fn">x'</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_filterMap'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4486-L4510">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_filterMap'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_filterMap'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">∀ (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>), <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.all">Option.all</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">p</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_map'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4512-L4517">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_map'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_map'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">∀ (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>), (<span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">p</span>)</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4519-L4525">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4527-L4534">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4536-L4543">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_filterMap'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4545-L4553">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_filterMap'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_filterMap'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">∀ (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>), <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.all">Option.all</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">p</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4555-L4562">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> :
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span>
      <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.snd_eq_getValueCast_of_getEntry?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4564-L4572">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.snd_eq_getValueCast_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">snd_eq_getValueCast_of_getEntry?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">y</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#cast">cast</a> <span class="fn">⋯</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.eq_getKey_getValue_of_getEntry?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4574-L4580">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eq_getKey_getValue_of_getEntry?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">eq_getKey_getValue_of_getEntry?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">y</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span>, <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_apply_of_containsKey_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4582-L4591">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_apply_of_containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_apply_of_containsKey_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> :
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span>
      <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isSome_apply_of_containsKey_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4593-L4602">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isSome_apply_of_containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_apply_of_containsKey_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> :
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_of_containsKey_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4604-L4612">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_of_containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_of_containsKey_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4614-L4628">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> else <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4630-L4644">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> then <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> else <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4646-L4651">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.apply_eq_true_of_containsKey_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4653-L4663">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.apply_eq_true_of_containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">apply_eq_true_of_containsKey_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4665-L4674">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4676-L4681">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4683-L4688">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>
    <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4690-L4701">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4703-L4708">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4710-L4715">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast?_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4717-L4726">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast?_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast!_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4728-L4733">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast!_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">k</span>)</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast!">getValueCast!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCastD_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4735-L4740">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCastD_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn"><span class="fn">γ</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCastD">getValueCastD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4742-L4748">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> :
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span>
      <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4750-L4755">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4757-L4762">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4764-L4769">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span>
    <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.any">Option.any</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">k</span> <span class="fn">x</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4771-L4776">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.any">Option.any</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_filter_key"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4778-L4783">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filter_key</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Option.exists_eq_some_and_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4785-L4787">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Option.exists_eq_some_and_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Option</span>.<span class="name">exists_eq_some_and_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">o</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">x</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn">o</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn">x</span></span>) <a href="../../../.././Init/Core.html#Iff">↔</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><span class="fn">o</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">p</span> <span class="fn">(<span class="fn"><span class="fn">o</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">h</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_filterMap_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4789-L4795">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_filterMap_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filterMap_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span>
      <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_filter_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4797-L4803">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_filter_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_filter_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_filterMap_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4805-L4814">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_filterMap_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filterMap_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.containsKey_filter_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4816-L4823">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.containsKey_filter_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">containsKey_filter_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4825-L4838">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4840-L4846">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4848-L4854">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>
    <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValueCast_eq_get_getValueCast?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4856-L4859">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast_eq_get_getValueCast?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValueCast_eq_get_getValueCast?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4861-L4872">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_filter_key"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4874-L4891">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_filter_key</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4893-L4899">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_filter_key"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4901-L4904">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_filter_key</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4906-L4912">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_filter_key"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4914-L4917">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_filter_key"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_filter_key</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4919-L4922">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4924-L4927">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4929-L4932">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4934-L4937">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn">γ</span> <span class="fn">a</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4939-L4943">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> :
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span>
      <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>
    <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4945-L4949">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4951-L4958">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4960-L4968">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> :
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getValue_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4970-L4975">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getValue_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_filterMap_eq_length_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4977-L4992">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_filterMap_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_filterMap_eq_length_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.key_getValueCast_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L4994-L5005">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.key_getValueCast_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">key_getValueCast_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">a</span>, <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.forall_mem_iff_forall_contains_getValueCast"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5007-L5017">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.forall_mem_iff_forall_contains_getValueCast"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">forall_mem_iff_forall_contains_getValueCast</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>), <span class="fn"><span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> → <span class="fn"><span class="fn">p</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span></span>)</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">p</span> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_filter_eq_length_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5019-L5024">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_filter_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_filter_eq_length_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.length_filter_key_eq_length_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5026-L5040">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.length_filter_key_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">length_filter_key_eq_length_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.perm_filter_self_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5042-L5046">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.perm_filter_self_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_filter_self_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> → <span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.perm_filter_self_iff_forall_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5048-L5057">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.perm_filter_self_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_filter_self_iff_forall_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.perm_filter_key_self_iff_forall_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5059-L5070">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.perm_filter_key_self_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">perm_filter_key_self_iff_forall_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.perm_filter_self_iff_forall_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5072-L5084">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.perm_filter_self_iff_forall_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">perm_filter_self_iff_forall_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_filterMap_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5086-L5091">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_filterMap_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filterMap_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_filterMap_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5093-L5098">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_filterMap_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filterMap_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> w</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">γ</span> <span class="fn">a</span>)</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn"><span class="fn">γ</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">k</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_filter_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5100-L5105">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_filter_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filter_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_filter_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5107-L5112">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_filter_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filter_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Core.html#LawfulBEq">LawfulBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">a</span></span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">k</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast">getValueCast</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isEmpty_filter_key_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5114-L5127">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isEmpty_filter_key_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isEmpty_filter_key_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey_getValue_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5131-L5140">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey_getValue_mem"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey_getValue_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span></span>, <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.forall_mem_iff_forall_contains_getKey_getValue"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5142-L5153">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.forall_mem_iff_forall_contains_getKey_getValue"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">forall_mem_iff_forall_contains_getKey_getValue</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">p</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././foundational_types.html">Prop</a></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">x</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>), <span class="fn"><span class="fn">x</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> → <span class="fn"><span class="fn">p</span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">x</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span></span>)</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">p</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5155-L5165">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pbind">pbind</a></span> <span class="fn">fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">v</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_filterMap_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5167-L5176">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_filterMap_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filterMap_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> →
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">k'</span> <span class="fn">x</span></span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5178-L5183">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pbind">pbind</a></span> <span class="fn">fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">v</span></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_filterMap_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5185-L5192">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_filterMap_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filterMap_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> →
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">k'</span> <span class="fn">x</span></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5194-L5199">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">γ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>
    <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pbind">pbind</a></span> <span class="fn">fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">v</span></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_filterMap_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5201-L5208">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_filterMap_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filterMap_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">γ</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> →
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>
      <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">k'</span> <span class="fn">x</span></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5210-L5221">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">v</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_filter_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5223-L5232">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_filter_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_filter_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> →
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">k'</span> <span class="fn">x</span></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5234-L5239">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">v</span></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_filter_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5241-L5247">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_filter_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_filter_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> →
  <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">k'</span> <span class="fn">x</span></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5249-L5254">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">v</span></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_filter_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5256-L5261">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_filter_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_filter_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">β</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Basic.html#Option.filter">Option.filter</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">k'</span> <span class="fn">x</span></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5263-L5271">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/Option/Instances.html#Option.pmap">Option.pmap</a> <span class="fn">(fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">v</span></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue?_map_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5273-L5277">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue?_map_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue?_map_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k'</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5279-L5284">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Instances.html#Option.pmap">Option.pmap</a> <span class="fn">(fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">v</span></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue!_map_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5286-L5290">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue!_map_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue!_map_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue!">getValue!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k'</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5292-L5297">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">γ</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Option/Instances.html#Option.pmap">Option.pmap</a> <span class="fn">(fun (<span class="fn">v</span> : <span class="fn">β</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">v</span></span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValueD_map_of_getKey?_eq_some"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5299-L5303">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValueD_map_of_getKey?_eq_some"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValueD_map_of_getKey?_eq_some</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">k'</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">γ</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueD">getValueD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(<span class="fn">f</span> <span class="fn">k'</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey?_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5305-L5318">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey?_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey!_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5320-L5326">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey!_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKeyD_filterMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5328-L5334">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKeyD_filterMap"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_filterMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>
    <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getValue_eq_get_getValue?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5336-L5339">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getValue_eq_get_getValue?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getValue_eq_get_getValue?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey?_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5341-L5351">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey?_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey?_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKey!_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5353-L5359">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKey!_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKey!_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.getKeyD_filter"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5361-L5367">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.getKeyD_filter"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">getKeyD_filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Instances.html#Option.pfilter">pfilter</a></span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">⋯</span>)</span></span></span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_filterMap_eq_length_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5369-L5384">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_filterMap_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_filterMap_eq_length_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_filter_eq_length_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5386-L5391">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_filter_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_filter_eq_length_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.length_filter_key_eq_length_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5393-L5398">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.length_filter_key_eq_length_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">length_filter_key_eq_length_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">a</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_filterMap_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5400-L5405">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_filterMap_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filterMap_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_filterMap_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5407-L5412">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_filterMap_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filterMap_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">γ</span></span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filterMap">List.filterMap</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">x</span> : <span class="fn">γ</span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn">x</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span>)</span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">k</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_filter_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5414-L5419">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_filter_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_filter_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5421-L5426">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_filter_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">k</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue">getValue</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_filter_key_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5428-L5432">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_filter_key_eq_true"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_key_eq_true</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>) (<span class="fn">h</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>), <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isEmpty_filter_key_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5434-L5438">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isEmpty_filter_key_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isEmpty_filter_key_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././Init/Prelude.html#Bool">Bool</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">distinct</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.filter">List.filter</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a> <a href="../../../.././Init/Core.html#Iff">↔</a>   <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">k</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn">α</span><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <a href="../../../.././Init/Core.html#Exists">∃</a> <a href="../../../.././Init/Core.html#Exists">(</a><span class="fn">h</span> <a href="../../../.././Init/Core.html#Exists">:</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a><a href="../../../.././Init/Core.html#Exists">)</a><a href="../../../.././Init/Core.html#Exists">,</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">k</span> <span class="fn">l</span> <span class="fn">h</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.toList_map'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5440-L5443">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.toList_map'"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">toList_map'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">γ</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.toList_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5445-L5448">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.toList_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">toList_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">γ</span> : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span>
  <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">γ</span></span>) =&gt; <a href="../../../.././Init/Prelude.html#Prod.mk">(</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">,</a> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span><a href="../../../.././Init/Prelude.html#Prod.mk">)</a>)</span> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">p</span> : <span class="fn">(_ : <span class="fn">α</span>) × <span class="fn">β</span></span>) =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>, <span class="fn"><span class="fn">f</span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">p</span>.<a href="../../../.././Init/Core.html#Sigma.snd">snd</a></span></span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>)</span> <span class="fn">l</span>)</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5488-L5490">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span></div></div><p>Like <code><a href="../../../.././Init/Data/List/Basic.html#List.min?">List.min?</a></code>, but using an <code><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a></code> typeclass instead of a <code><a href="../../../.././Init/Prelude.html#Min">Min</a></code> typeclass.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">Std.Internal.List.minEntry?</a> <span class="fn">xs</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">xs</span>.<a href="../../../.././Init/Data/List/Basic.html#List.min?">min?</a></span></li></ul></details><details id="instances-for-list-Std.Internal.List.minEntry?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.minKey?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5492-L5494">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></div></div><p>Returns the smallest key in an associative list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">Std.Internal.List.minKey?</a> <span class="fn">xs</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <a href="../../../.././Init/Core.html#Sigma.fst">Sigma.fst</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">Std.Internal.List.minEntry?</a> <span class="fn">xs</span>)</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.minKey?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.DistinctKeys.eq_of_mem_of_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5496-L5508">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.DistinctKeys.eq_of_mem_of_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">DistinctKeys</span>.<span class="name">eq_of_mem_of_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/BEq.html#EquivBEq">EquivBEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hma</span> : <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hmb</span> : <span class="fn">b</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : (<span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_eq_head?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5520-L5522">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_eq_head?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_eq_head?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.head?">head?</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5524-L5526">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_nil"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <a href="../../../.././Init/Prelude.html#List.nil">[</a><a href="../../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minEntry?_of_isEmpty_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5535-L5539">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minEntry?_of_isEmpty_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_of_isEmpty_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_eq_some_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5559-L5574">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_eq_some_iff"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_eq_some_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">a</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">b</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_some_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5576-L5585">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_some_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_some_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5587-L5599">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_some_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5601-L5609">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5611-L5614">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_eq_none_iff_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5616-L5618">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_eq_none_iff_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_eq_none_iff_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_none_iff_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5620-L5622">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_none_iff_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_none_iff_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_of_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5624-L5626">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_of_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_of_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.isNone_minEntry?_eq_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5628-L5631">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isNone_minEntry?_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isNone_minEntry?_eq_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isNone_minKey?_eq_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5633-L5635">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isNone_minKey?_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isNone_minKey?_eq_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minEntry?_eq_not_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5637-L5641">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minEntry?_eq_not_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_eq_not_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minKey?_eq_not_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5643-L5645">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minKey?_eq_not_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_eq_not_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minKey?_iff_isEmpty_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5647-L5649">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minKey?_iff_isEmpty_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_iff_isEmpty_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5656-L5667">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span> → <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn">∀ (<span class="fn">e₁ </span><span class="fn">e₂</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>), <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">e₁</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">e₂</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">e₁</span>)</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">e₂</span>)</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">(<a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.replaceEntry_eq_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5669-L5688">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry_eq_map"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">replaceEntry_eq_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">(fun (<span class="fn">e</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">e</span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_replaceEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5690-L5700">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_replaceEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_replaceEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.replaceEntry">replaceEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">e</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">e</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minEntry?_of_contains"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5702-L5708">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minEntry?_of_contains"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_of_contains</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5710-L5730">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a>
    <span class="fn">(match <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> with
    | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">w</span></span> =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn"><span class="fn">w</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">w</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5732-L5737">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minEntry?_insert"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5739-L5742">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minEntry?_insert"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_insert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5744-L5747">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minEntry?_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5749-L5752">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minEntry?_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minKey?_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5754-L5757">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minKey?_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getEntry?_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5759-L5763">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getEntry?_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">em</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hem</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">em</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn"><span class="fn">em</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">em</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_bind_getEntry?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5765-L5771">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_bind_getEntry?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_bind_getEntry?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">k</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getEntry?">getEntry?</a> <span class="fn">k</span> <span class="fn">l</span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5773-L5776">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5787-L5792">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">km</span> <span class="fn">l</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5794-L5798">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5800-L5804">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">km</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_bind_getKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5806-L5811">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_bind_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_bind_getKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">k</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5813-L5818">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eraseKey_eq_iff_beq_minKey?_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5820-L5827">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eraseKey_eq_iff_beq_minKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eraseKey_eq_iff_beq_minKey?_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ {<span class="fn">km</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> → (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">km</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eraseKey_eq_of_beq_minKey?_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5829-L5835">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eraseKey_eq_of_beq_minKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eraseKey_eq_of_beq_minKey?_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn">∀ {<span class="fn">km</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> → (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">km</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_insertEntry_le_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5837-L5842">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_insertEntry_le_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntry_le_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">kmi</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_insertEntry_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5844-L5852">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntry_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">kmi</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_le_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5854-L5859">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_le_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5861-L5871">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span>)</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minKey?_of_isSome_minKey?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5873-L5876">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minKey?_of_isSome_minKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_of_isSome_minKey?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_minKey?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5878-L5883">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_minKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">kme</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkme</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">kme</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">kme</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_le_minKey?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5885-L5892">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_le_minKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_le_minKey?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">km </span><span class="fn">kme</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkme</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">kme</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">kme</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5894-L5901">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_cons"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> (<span class="fn">e</span> <a href="../../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a>
    <span class="fn">(match <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> with
    | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span>
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">w</span></span> =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn">w</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">w</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minEntry?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5903-L5932">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minEntry?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a>
    <span class="fn">(match <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">l</span></span> with
    | <a href="../../../.././Init/Prelude.html#Option.none">none</a> =&gt; <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a>
    | <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">e</span></span> =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn"><span class="fn">e</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <a href="../../../.././Init/Core.html#Sigma.mk">⟨</a><span class="fn">k</span>, <span class="fn">v</span><a href="../../../.././Init/Core.html#Sigma.mk">⟩</a> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">e</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5934-L5939">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minEntry?_insertIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5941-L5944">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minEntry?_insertIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minEntry?_insertIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minEntry?">minEntry?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_minKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5946-L5949">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_minKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_minKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_insertEntryIfNew_le_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5951-L5956">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_insertEntryIfNew_le_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntryIfNew_le_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">kmi</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_insertEntryIfNew_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5958-L5969">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_insertEntryIfNew_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">kmi</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_head?_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5971-L5974">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_head?_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_head?_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.head?">head?</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5976-L5981">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L5983-L5999">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6005-L6023">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">km</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">km</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">km</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey?_modifyKey_eq_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6025-L6032">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey?_modifyKey_eq_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_modifyKey_eq_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isSome_minKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6034-L6037">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isSome_minKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_minKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isSome_minKey?_modifyKey_eq_isSome"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6039-L6042">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isSome_minKey?_modifyKey_eq_isSome"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_minKey?_modifyKey_eq_isSome</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey?_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6044-L6054">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey?_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">kmm</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmm</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn">kmm</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">km</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey?_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6056-L6073">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey?_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6077-L6079">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">xs</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Given a proof that the list is nonempty, returns the smallest key in an associative list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">Std.Internal.List.minKey</a> <span class="fn">xs</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">Std.Internal.List.minKey?</a> <span class="fn">xs</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.minKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.minKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6081-L6084">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hl</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">hl</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l'</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eq_get_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6086-L6089">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eq_get_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_get_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_some_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6091-L6094">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_some_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eq_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6096-L6100">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eq_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6102-L6105">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6107-L6111">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_insertEntry_le_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6113-L6117">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_insertEntry_le_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntry_le_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_insertEntry_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6119-L6123">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntry_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6125-L6128">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_le_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6130-L6133">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_le_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6135-L6139">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6141-L6144">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6146-L6149">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6151-L6154">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6156-L6159">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eraseKey_eq_iff_beq_minKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6161-L6173">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eraseKey_eq_iff_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eraseKey_eq_iff_beq_minKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eraseKey_eq_of_beq_minKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6175-L6180">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eraseKey_eq_of_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eraseKey_eq_of_beq_minKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_le_minKey_erase"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6182-L6186">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_le_minKey_erase"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_le_minKey_erase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">he</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6188-L6192">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_insertEntryIfNew_le_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6194-L6198">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_insertEntryIfNew_le_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntryIfNew_le_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_insertEntryIfNew_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6200-L6203">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_insertEntryIfNew_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eq_head_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6205-L6209">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eq_head_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_head_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.head">head</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6211-L6214">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6216-L6220">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6226-L6233">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey_modifyKey_eq_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6235-L6238">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey_modifyKey_eq_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_modifyKey_eq_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6240-L6243">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6245-L6249">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6253-L6255">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Returns the smallest key in an associative list or panics if the list is empty.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">Std.Internal.List.minKey!</a> <span class="fn">xs</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">Std.Internal.List.minKey?</a> <span class="fn">xs</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></li></ul></details><details id="instances-for-list-Std.Internal.List.minKey!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.minKey!_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6257-L6260">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eq_get!_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6262-L6265">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eq_get!_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_get!_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eq_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6267-L6270">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eq_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_some_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6272-L6275">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_some_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eq_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6277-L6280">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eq_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6282-L6285">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eq_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6287-L6291">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6293-L6297">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_insertEntry_le_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6299-L6302">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_insertEntry_le_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntry_le_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_insertEntry_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6304-L6307">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntry_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6309-L6312">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_le_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6314-L6317">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_le_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6319-L6322">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6324-L6327">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6329-L6332">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_minKey!_eq_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6334-L6337">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_minKey!_eq_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKey!_eq_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6339-L6342">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6344-L6347">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eraseKey_eq_iff_beq_minKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6349-L6353">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eraseKey_eq_iff_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eraseKey_eq_iff_beq_minKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eraseKey_eq_iff_beq_minKey!_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6355-L6359">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eraseKey_eq_iff_beq_minKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eraseKey_eq_iff_beq_minKey!_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eraseKey_eq_of_beq_minKey!_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6361-L6365">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eraseKey_eq_of_beq_minKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eraseKey_eq_of_beq_minKey!_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">heq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_le_minKey!_erase"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6367-L6370">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_le_minKey!_erase"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_le_minKey!_erase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6372-L6376">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_insertEntryIfNew_le_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6378-L6381">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_insertEntryIfNew_le_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntryIfNew_le_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_insertEntryIfNew_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6383-L6386">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_insertEntryIfNew_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eq_head!_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6388-L6394">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eq_head!_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_head!_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/BasicAux.html#List.head!">head!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6396-L6403">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6405-L6410">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6416-L6419">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey!_modifyKey_eq_minKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6421-L6428">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey!_modifyKey_eq_minKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_modifyKey_eq_minKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey!_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6430-L6437">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey!_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKey!_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6439-L6443">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKey!_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6447-L6449">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fallback</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Returns the smallest key in an associative list or <code>fallback</code> if the list is empty.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">Std.Internal.List.minKeyD</a> <span class="fn">xs</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">Std.Internal.List.minKey?</a> <span class="fn">xs</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.minKeyD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.minKeyD_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6451-L6454">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l'</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eq_getD_minKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6456-L6459">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eq_getD_minKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_getD_minKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey_eq_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6461-L6464">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey_eq_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey_eq_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey?_eq_some_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6466-L6469">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?_eq_some_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey?_eq_some_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKey!_eq_minKeyD_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6471-L6474">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!_eq_minKeyD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKey!_eq_minKeyD_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey!">minKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eq_fallback"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6476-L6479">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_fallback</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eq_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6481-L6486">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eq_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6488-L6493">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6495-L6499">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_insertEntry_le_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6501-L6504">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_insertEntry_le_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntry_le_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_insertEntry_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6506-L6509">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_insertEntry_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntry_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6511-L6514">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_le_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6516-L6519">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_le_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6521-L6524">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6526-L6529">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6531-L6535">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_minKeyD_eq_minKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6537-L6541">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_minKeyD_eq_minKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_minKeyD_eq_minKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">minKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6543-L6546">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6548-L6551">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback </span><span class="fn">fallback'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span> <span class="fn">fallback'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eraseKey_eq_iff_beq_minKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6553-L6559">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eraseKey_eq_iff_beq_minKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eraseKey_eq_iff_beq_minKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eraseKey_eq_iff_beq_minKeyD_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6561-L6567">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eraseKey_eq_iff_beq_minKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eraseKey_eq_iff_beq_minKeyD_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eraseKey_eq_of_beq_minKeyD_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6569-L6574">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eraseKey_eq_of_beq_minKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eraseKey_eq_of_beq_minKeyD_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">heq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_le_minKeyD_erase"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6576-L6581">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_le_minKeyD_erase"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_le_minKeyD_erase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6583-L6587">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">minKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_insertEntryIfNew_le_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6589-L6593">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_insertEntryIfNew_le_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntryIfNew_le_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_insertEntryIfNew_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6595-L6598">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_insertEntryIfNew_le_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_insertEntryIfNew_le_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_eq_headD_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6600-L6603">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_eq_headD_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_eq_headD_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.headD">headD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6605-L6612">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.minKeyD_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6614-L6619">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">minKeyD_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKeyD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6625-L6629">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKeyD_modifyKey_eq_minKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6631-L6638">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKeyD_modifyKey_eq_minKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_modifyKey_eq_minKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKeyD_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6640-L6647">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKeyD_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.minKeyD_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6649-L6654">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.minKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">minKeyD_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">minKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">k'</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6662-L6665">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></div></div><p>Returns the largest key in an associative list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">Std.Internal.List.maxKey?</a> <span class="fn">xs</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey?">Std.Internal.List.minKey?</a> <span class="fn">xs</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.maxKey?" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_some_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6667-L6671">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_some_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_some_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6673-L6677">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_some_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6679-L6683">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_none_iff_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6685-L6688">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_none_iff_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_none_iff_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_of_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6690-L6693">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_of_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_of_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Option.none">none</a></div></div></div></div><div class="decl" id="Std.Internal.List.isNone_maxKey?_eq_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6695-L6698">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isNone_maxKey?_eq_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isNone_maxKey?_eq_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isNone">isNone</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_maxKey?_eq_not_isEmpty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6700-L6703">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_maxKey?_eq_not_isEmpty"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_eq_not_isEmpty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_maxKey?_iff_isEmpty_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6705-L6708">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_maxKey?_iff_isEmpty_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_iff_isEmpty_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6710-L6715">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_maxKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6717-L6721">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_maxKey?_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6723-L6727">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_maxKey?_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6729-L6733">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6735-L6739">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">km</span> <span class="fn">l</span> <span class="fn">hc</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6741-L6745">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6747-L6751">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">km</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_bind_getKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6753-L6757">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_bind_getKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_bind_getKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.bind">bind</a></span> <span class="fn">fun (<span class="fn">k</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">k</span> <span class="fn">l</span></span></span>)</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6759-L6763">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eraseKey_eq_iff_beq_maxKey?_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6765-L6769">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eraseKey_eq_iff_beq_maxKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eraseKey_eq_iff_beq_maxKey?_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ {<span class="fn">km</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> → (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">km</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eraseKey_eq_of_beq_maxKey?_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6771-L6776">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eraseKey_eq_of_beq_maxKey?_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eraseKey_eq_of_beq_maxKey?_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn">∀ {<span class="fn">km</span> : <span class="fn">α</span>}, <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> → (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">km</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_le_maxKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6778-L6783">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_le_maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le_maxKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">kmi</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKey?_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6785-L6790">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKey?_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey?_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">kmi</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_le_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6792-L6797">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_le_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6799-L6804">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k'</span></span> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span>)</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_maxKey?_of_isSome_maxKey?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6806-L6810">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_maxKey?_of_isSome_maxKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_of_isSome_maxKey?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_maxKey?_eraseKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6812-L6817">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_maxKey?_eraseKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey?_eraseKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">kme</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkme</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">kme</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">kme</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eraseKey_le_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6819-L6826">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eraseKey_le_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eraseKey_le_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">km </span><span class="fn">kme</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkme</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">kme</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">kme</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6828-L6833">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.isSome_maxKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6835-L6839">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.isSome_maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">isSome_maxKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_le_maxKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6841-L6846">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_le_maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_le_maxKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">km</span> <span class="fn">kmi</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKey?_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6848-L6853">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKey?_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey?_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">kmi</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmi</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmi</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">kmi</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.reverse_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6855-L6857">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.reverse_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">reverse_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_getLast?_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6859-L6865">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_getLast?_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_getLast?_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.getLast?">getLast?</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6867-L6871">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6873-L6878">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6884-L6888">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">(fun (<span class="fn">km</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn">km</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">km</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey?_modifyKey_eq_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6890-L6894">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey?_modifyKey_eq_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_modifyKey_eq_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isSome_maxKey?_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6896-L6900">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isSome_maxKey?_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_maxKey?_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.not">!</a><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.isSome_maxKey?_modifyKey_eq_isSome"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6902-L6906">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.isSome_maxKey?_modifyKey_eq_isSome"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">isSome_maxKey?_modifyKey_eq_isSome</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey?_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6908-L6914">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey?_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">kmm</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkm</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hkmm</span> : <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">kmm</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type">(<span class="fn">kmm</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">km</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey?_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6916-L6921">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey?_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey?_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">k</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6925-L6927">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">xs</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Given a proof that the list is nonempty, returns the largest key in an associative list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">Std.Internal.List.maxKey</a> <span class="fn">xs</span> <span class="fn">h</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKey">Std.Internal.List.minKey</a> <span class="fn">xs</span> <span class="fn">h</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.maxKey" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.maxKey_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6929-L6933">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hl</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">hl</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l'</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eq_get_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6935-L6938">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eq_get_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_get_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.get">get</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_some_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6940-L6944">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_some_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eq_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6946-L6950">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eq_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6952-L6956">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6958-L6963">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_le_maxKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6965-L6969">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_le_maxKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_le_maxKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKey_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6971-L6975">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKey_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6977-L6981">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_maxKey_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6983-L6987">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_maxKey_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_maxKey_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6989-L6993">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L6995-L6999">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7001-L7005">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7007-L7011">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7013-L7017">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eraseKey_eq_iff_beq_maxKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7019-L7025">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eraseKey_eq_iff_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eraseKey_eq_iff_beq_maxKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eraseKey_eq_of_beq_maxKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7027-L7033">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eraseKey_eq_of_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eraseKey_eq_of_beq_maxKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eraseKey_le_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7035-L7040">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eraseKey_le_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eraseKey_le_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">he</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7042-L7047">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_le_maxKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7049-L7054">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_le_maxKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_le_maxKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKey_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7056-L7060">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKey_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">⋯</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eq_getLast_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7062-L7068">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eq_getLast_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_getLast_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.getLast">getLast</a></span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7070-L7074">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7076-L7081">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7087-L7095">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey_modifyKey_eq_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7097-L7101">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey_modifyKey_eq_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_modifyKey_eq_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7103-L7107">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7109-L7114">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7118-L7120">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Given a proof that the list is nonempty, returns the smallest key in an associative list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">Std.Internal.List.maxKey!</a> <span class="fn">xs</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">Std.Internal.List.maxKey?</a> <span class="fn">xs</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></li></ul></details><details id="instances-for-list-Std.Internal.List.maxKey!" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.maxKey!_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7122-L7126">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l'</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eq_get!_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7128-L7132">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eq_get!_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_get!_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/BasicAux.html#Option.get!">get!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eq_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7134-L7138">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eq_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_some_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7140-L7144">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_some_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eq_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7146-L7150">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eq_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eq_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7152-L7156">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eq_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7158-L7163">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7165-L7170">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_le_maxKey!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7172-L7176">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_le_maxKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_le_maxKey!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKey!_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7178-L7182">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKey!_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey!_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7184-L7188">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_maxKey!_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7190-L7194">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_maxKey!_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_maxKey!_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7196-L7200">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7202-L7206">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7208-L7212">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_maxKey!_eq_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7214-L7218">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_maxKey!_eq_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKey!_eq_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7220-L7224">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7226-L7230">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eraseKey_eq_iff_beq_maxKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7232-L7237">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eraseKey_eq_iff_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eraseKey_eq_iff_beq_maxKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eraseKey_eq_iff_beq_maxKey!_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7239-L7244">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eraseKey_eq_iff_beq_maxKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eraseKey_eq_iff_beq_maxKey!_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eraseKey_eq_of_beq_maxKey!_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7246-L7251">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eraseKey_eq_of_beq_maxKey!_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eraseKey_eq_of_beq_maxKey!_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">heq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_erase_le_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7253-L7257">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_erase_le_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_erase_le_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7259-L7264">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_le_maxKey!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7266-L7270">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_le_maxKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_le_maxKey!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKey!_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7272-L7276">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKey!_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKey!_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eq_getLast!_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7278-L7283">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eq_getLast!_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_getLast!_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/BasicAux.html#List.getLast!">getLast!</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7285-L7289">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7291-L7297">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey!_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7303-L7307">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey!_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey!_modifyKey_eq_maxKey!"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7309-L7313">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey!_modifyKey_eq_maxKey!"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_modifyKey_eq_maxKey!</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey!_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7315-L7319">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey!_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKey!_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7321-L7326">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKey!_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKey!_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7330-L7332">source</a></div><div class="attributes">@[reducible, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">fallback</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Returns the smallest key in an associative list or <code>fallback</code> if the list is empty.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">Std.Internal.List.maxKeyD</a> <span class="fn">xs</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.minKeyD">Std.Internal.List.minKeyD</a> <span class="fn">xs</span> <span class="fn">fallback</span></span></li></ul></details><details id="instances-for-list-Std.Internal.List.maxKeyD" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Internal.List.maxKeyD_of_perm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7334-L7338">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_of_perm"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_of_perm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l'</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eq_getD_maxKey?"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7340-L7344">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eq_getD_maxKey?"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_getD_maxKey?</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Prelude.html#Option.getD">getD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey_eq_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7346-L7350">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey_eq_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey_eq_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey?_eq_some_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7352-L7356">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?_eq_some_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey?_eq_some_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKey!_eq_maxKeyD_default"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7358-L7362">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!_eq_maxKeyD_default"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKey!_eq_maxKeyD_default</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey!">maxKey!</a> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <a href="../../../.././Init/Prelude.html#Inhabited.default">default</a></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eq_fallback"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7364-L7368">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eq_fallback"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_fallback</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fallback</span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eq_iff_getKey?_eq_self_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7370-L7375">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eq_iff_getKey?_eq_self_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_iff_getKey?_eq_self_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">km</span></span> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eq_iff_mem_and_forall"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7377-L7382">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eq_iff_mem_and_forall"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_iff_mem_and_forall</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">km </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">km</span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">km</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">km</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7384-L7389">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_le_maxKeyD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7391-L7395">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_le_maxKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_le_maxKeyD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKeyD_insertEntry"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7397-L7401">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKeyD_insertEntry"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKeyD_insertEntry</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntry">insertEntry</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.containsKey_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7403-L7407">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">containsKey_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.le_maxKeyD_of_containsKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7409-L7413">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.le_maxKeyD_of_containsKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">le_maxKeyD_of_containsKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7415-L7419">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_le"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey?_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7421-L7425">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey?_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey?">getKey?</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7427-L7431">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey_maxKeyD_eq_maxKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7433-L7437">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey_maxKeyD_eq_maxKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey_maxKeyD_eq_maxKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">he</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey">getKey</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span> <span class="fn">he</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey">maxKey</a> <span class="fn">l</span> <span class="fn">⋯</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKey!_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7439-L7443">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKey!_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKey!">getKey!</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.getKeyD_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7445-L7449">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">getKeyD_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback </span><span class="fn">fallback'</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getKeyD">getKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">l</span> <span class="fn">fallback'</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eraseKey_eq_iff_beq_maxKey_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7451-L7457">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eraseKey_eq_iff_beq_maxKey_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_eq_iff_beq_maxKey_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eraseKey_eq_iff_beq_maxKeyD_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7459-L7465">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eraseKey_eq_iff_beq_maxKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_eq_iff_beq_maxKeyD_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eraseKey_eq_of_beq_maxKeyD_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7467-L7472">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eraseKey_eq_of_beq_maxKeyD_eq_false"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_eq_of_beq_maxKeyD_eq_false</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k </span><span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">heq</span> : (<span class="fn">k</span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eraseKey_le_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7474-L7479">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eraseKey_le_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eraseKey_le_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.eraseKey">eraseKey</a> <span class="fn">k</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7481-L7486">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKey?">maxKey?</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.elim">elim</a></span> <span class="fn">k</span> <span class="fn">fun (<span class="fn">k'</span> : <span class="fn">α</span>) =&gt; <a href="../../../.././Init/Prelude.html#ite">if</a> <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn">k'</span></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_le_maxKeyD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7488-L7492">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_le_maxKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_le_maxKeyD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">l</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span>)</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.self_le_maxKeyD_insertEntryIfNew"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7494-L7498">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.self_le_maxKeyD_insertEntryIfNew"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">self_le_maxKeyD_insertEntryIfNew</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">v</span> : <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.insertEntryIfNew">insertEntryIfNew</a> <span class="fn">k</span> <span class="fn">v</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span>)</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_eq_getLastD_keys"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7500-L7505">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_eq_getLastD_keys"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_eq_getLastD_keys</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ho</span> : <span class="fn"><a href="../../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(fun (<span class="fn">a</span> <span class="fn">b</span> : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>) =&gt; <span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn"><span class="fn">a</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span> <span class="fn"><span class="fn">b</span>.<a href="../../../.././Init/Core.html#Sigma.fst">fst</a></span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Data/Ord.html#Ordering.lt">Ordering.lt</a>)</span> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.keys">keys</a> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.getLastD">getLastD</a></span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7507-L7511">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><span class="fn">β</span> <span class="fn">k</span></span> → <span class="fn"><span class="fn">β</span> <span class="fn">k</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.maxKeyD_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7513-L7519">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">maxKeyD_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <span class="fn"><span class="fn">α</span> → <a href="../../../.././foundational_types.html">Type</a> v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((<span class="fn">a</span> : <span class="fn">α</span>) × <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn">β</span> <span class="fn">k</span>)</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValueCast?">getValueCast?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKeyD_modifyKey"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7525-L7530">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKeyD_modifyKey"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_modifyKey</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#ite">if</a> (<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#ite">then</a> <span class="fn">k</span> <a href="../../../.././Init/Prelude.html#ite">else</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKeyD_modifyKey_eq_maxKeyD"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7532-L7536">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKeyD_modifyKey_eq_maxKeyD"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_modifyKey_eq_maxKeyD</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulEqOrd">LawfulEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKeyD_modifyKey_beq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7538-L7542">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKeyD_modifyKey_beq"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_modifyKey_beq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type">(<span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.modifyKey">modifyKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">l</span> <span class="fn">fallback</span></span>) <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></div></div></div></div><div class="decl" id="Std.Internal.List.Const.maxKeyD_alterKey_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/ad1a017949674a947f0d6794cbf7130d642c6530/src/Std/Data/Internal/List/Associative.lean#L7544-L7550">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.maxKeyD_alterKey_eq_self"><span class="name">Std</span>.<span class="name">Internal</span>.<span class="name">List</span>.<span class="name">Const</span>.<span class="name">maxKeyD_alterKey_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Data/Ord.html#Ord">Ord</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.TransOrd">TransOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Std/Classes/Ord/Basic.html#Std.LawfulBEqOrd">LawfulBEqOrd</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../../.././Init/Prelude.html#List">List</a> <span class="fn">((_ : <span class="fn">α</span>) × <span class="fn">β</span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hd</span> : <span class="fn"><a href="../../../.././Std/Data/Internal/List/Defs.html#Std.Internal.List.DistinctKeys">DistinctKeys</a> <span class="fn">l</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">k</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span> → <span class="fn"><a href="../../../.././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">he</span> : <span class="fn"><span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../../.././Init/Data/List/Basic.html#List.isEmpty">isEmpty</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.false">false</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">fallback</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.maxKeyD">maxKeyD</a> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.Const.alterKey">alterKey</a> <span class="fn">k</span> <span class="fn">f</span> <span class="fn">l</span>)</span> <span class="fn">fallback</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn">k</span> <a href="../../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><span class="fn">(<span class="fn">f</span> <span class="fn">(<a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.getValue?">getValue?</a> <span class="fn">k</span> <span class="fn">l</span>)</span>)</span>.<a href="../../../.././Init/Data/Option/Basic.html#Option.isSome">isSome</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> <a href="../../../.././Init/Prelude.html#And">∧</a> <span class="fn">∀ (<span class="fn">k'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn"><a href="../../../.././Std/Data/Internal/List/Associative.html#Std.Internal.List.containsKey">containsKey</a> <span class="fn">k'</span> <span class="fn">l</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a> → <span class="fn"><span class="fn">(<a href="../../../.././Init/Data/Ord.html#Ord.compare">compare</a> <span class="fn">k'</span> <span class="fn">k</span>)</span>.<a href="../../../.././Init/Data/Ord.html#Ordering.isLE">isLE</a></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>